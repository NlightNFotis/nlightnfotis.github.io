
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Fotis Koutoulakis</title>
  <meta name="author" content="Fotis Koutoulakis">

  
  <meta name="description" content="Tweet Distro Forking 101: How Do You Fork a Linux Distro? Jul 9th, 2014 Defining the GNU/Linux distribution If you are here, we can safely assume &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://NlightNFotis.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Fotis Koutoulakis" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42432516-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body >
  <header role="banner" id="sidebar">
    <!-- Logo -->
<!-- This is ugly as hell, but does well for now. -->
<!-- TODO: Move this in a seperate stylesheet. -->
<style>
IMG.displayed {
    display: block;
    margin-left: auto;
    margin-right: auto;
    vertical-align: text-bottom;
}
</style>

<IMG class="displayed" src="../../images/me2.png">


<ul id="menu">

  <li class="title">
    <h1 id="title"><a href="/">Fotis Koutoulakis</a></h1>
  </li>


  <li class="subtitle">
    <h2 id="subtitle">I spend my time pretending I know about computers.</h2>
  </li>

  <li class="link">
    <img src="../../images/email.png">
    <a href="/about/">about</a>
  </li>

  <li class="link">
    <img src="../../images/glyphicons_391_twitter_t.png">
    <a href="http://twitter.com/NlightNFotis/">twitter</a>
  </li>


  <li class="link">
    <img src="../../images/glyphicons_381_github.png">
    <a href="http://github.com/NlightNFotis/">github</a>
  </li>

  <li class="link rss">
    <img src="../../images/glyphicons_social_37_rss.png">
    <a href="/atom.xml">rss feed</a>
  </li>
</ul>


<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:NlightNFotis.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>


<!-- Octopress Love -->
<aside id="octopress_linkback">
  <a href="http://octopress.org/">
    <span class="unicode_square">
      <span class="unicode_circle">
        &nbsp;
      </span>
    </span>
    <span class="octopress">Powered by Octopress</span>
  </a>
</aside>


  </header>
  <section id="main">
      
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2014/07/09/distro-forking-101/">Distro Forking 101: How Do You Fork a Linux Distro?</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-09T15:04:00+03:00" pubdate data-updated="true">Jul 9<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <h1 id="defining-the-gnulinux-distribution">Defining the GNU/Linux distribution</h1>

<p>If you are here, we can safely assume that you already know what a <strong>GNU/Linux software
distribution</strong> is, but for completion‚Äôs sake, let‚Äôs just define so we all have the same context.</p>

<p>A GNU/Linux distribution is a collection of system and application software, packaged together
by the distribution‚Äôs developers, so that they are distributed in a nicely integrated bundle, ready
to be used by users and developers alike. Software typically included in such a distribution
ranges from a compiler toolchain, to the C library, to filesystem utilities to text editors.</p>

<p>As you can imagine, from the existence of several different GNU/Linux distributions, there are 
multiple ways that you could possibly combine all these different applications and their respective
configurations, not to mention that you could include even more specialised software, depending
on the target audience of the distribution (such as multimedia software for a distribution like 
<a href="http://ubuntustudio.org/">Ubuntu Studio</a> or penetration testing tools for a distribution such as
<a href="http://www.kali.org/">Kali Linux</a>)</p>

<h1 id="the-f-word">The ‚Äúf‚Äù word</h1>

<p>But even with such a great number of different software collections and their respective configurations
there still may not be one that appeals to your specific needs. That‚Äôs ok though, as you can still
customize each and every distribution to your specific liking. Extensive customization is known to
create a <em>differentiation point</em> known as a <strong>potential forking point</strong>.</p>

<p>Forking is a term that has been known to carry negative connotations. <a href="http://en.wikipedia.org/wiki/Fork_%28software_development%29">As wikipedia puts it</a>, </p>

<blockquote>
  <p>the term often implies not merely a development branch, but a split in the developer community
a form of schism.</p>
</blockquote>

<p>Historically, it has also been used as a leverage to coerce a project‚Äôs developers 
into merging code into their master branches
that they didn‚Äôt originally want to, or otherwise take a decision that they wouldn‚Äôt have taken
if not under the pressure of a <em>‚Äúfork‚Äù</em>. But why is it so?</p>

<p>You see, traditionally, forking a project meant a couple of things: For starters, there were now
two, identical projects, competing in the same solution space. 
Those two projects had different development hours and 
features or bug fixes going into them, and eventually, one of the two ended up being obsolete.
Apart from that forking also created an atmosphere of intense competition among the two projects.</p>

<p>However, in 2014, and the advent of the distributed version control systems such as <a href="http://git-scm.com/">git</a> 
and <a href="http://mercurial.selenic.com/">mercurial</a> and of the social coding websites such as <a href="http://www.github.com">Github</a> and <a href="http://www.bitbucket.org">Bitbucket</a>, the term is finally taking
on a more lax meaning, as just another code repository that may or may not enjoy major 
(or even minor, for that matter) development.</p>

<h2 id="forking-a-gnulinux-distribution">Forking a GNU/Linux distribution</h2>

<p>So, up until now we have discussed what a GNU/Linux distribution is, and what a fork is. 
However, we haven‚Äôt discussed yet what it means to fork a GNU/Linux distribution.</p>

<p>You see, what differentiates each distro from the other ones, apart from the software collection 
that they contain, is the way in which they provide (and deploy) that software. Yes, we are talking about software packages and their respective package managers. Distributions from the Debian
(.deb) family are using <code>dpkg</code> along with <code>apt</code> or <code>synaptic</code> or <code>aptitude</code> or some other higher level
tool. RPM (.rpm) based distributions may use <code>rpm</code> with <code>yum</code> or <code>dnf</code> or  <code>zypper</code> or another higher level tool. 
Other distributions, not based on the aforementioned may choose to roll their own configuration
of packages and package managers, with Arch Linux using its own <code>pacman</code>, Sabayon uses its <code>entropy</code>
package manager, etc.</p>

<p>Now, naturally, if you want to customize an application to your liking, you have many ways in which
you could do that. One of them is downloading the tarball from the upstream‚Äôs website or ftp 
server, <code>./configure</code> it and then <code>make</code> and <code>make install</code> it. But if you do start customizing
lots of applications this way, it can become tedious and unwieldy too soon. After all, what did
that <code>make install</code> install exactly? Will the new update replace those files? What were your
configuration options? Did they replace the files the package manager installed?</p>

<p>In this case, it really pays off to learn <strong>packaging</strong> software for your distribution of choice.
What this means is to learn the format of packages your distribution‚Äôs package manager accepts
as well as how you could produce them. This way, instead of the <code>./configure &amp;&amp; make &amp;&amp; make install</code> 
cycle, you just have beautiful software packages, that you can control more tightly, you can 
update more easily and you can also distribute them to your friends if you so desire. As an added
bonus, now the package manager also knows about those files, and you can install, remove
or update them much more easily. What‚Äôs not to like?</p>

<p>After you have created some custom packages, you may also wish to create a repository
to contain them and update straight from that. <strong>Congratulations, you have created your custom
distribution, and a potential fork.</strong> While you are at it, if you really want to fork the distribution,
you could as well take the distribution‚Äôs <code>base</code> packages, customize them, rebuild them, and then
distribute them. <strong>Congratulations again, now you have your true GNU/Linux distribution fork</strong>.</p>

<h1 id="that-seems-easy-more-specifically">That seems easy. More specifically?</h1>

<p>Yes of course. Let‚Äôs take a look at how you might want to go about forking some well known
GNU/Linux distribution.</p>

<h2 id="debian">Debian</h2>

<p>In Debian, your usual procedure if you wish to customize a package is the below:</p>

<ul>
  <li>First, you make sure you have the essential building software installed. <code>apt-get install build-essential devscripts debhelper</code></li>
  <li>Then you need to download the package‚Äôs build dependencies. <code>apt-get build-dep $package_name</code></li>
  <li>Now it‚Äôs time to download it‚Äôs sources, via <code>apt-get source $package_name</code></li>
  <li>Proceed with customizing it to your liking (update it, patch the sources, etc)</li>
  <li>Now it‚Äôs time to rebuild it. <code>debuild -us -uc</code></li>
</ul>

<p>Assuming all went fine, you should now have an <code>$package_name.deb</code> file in your current 
directory ready to be installed with <code>dpkg -i $package_name.deb</code>.</p>

<p>Please take note that the above is not an extensive treatise into debian packaging by any means.
If you want to build custom debian packages, here are some links:</p>

<ul>
  <li><a href="https://wiki.debian.org/IntroDebianPackaging">Debian wiki: intro to Debian packaging</a></li>
  <li><a href="http://people.connexer.com/~roberto/howtos/debcustomize">Roberto C Sanchez: Debian package customization how to</a></li>
  <li><a href="https://wiki.debian.org/HowToPackageForDebian">Debian wiki: How to package for Debian</a></li>
</ul>

<p>Now that you have your custom packages, it‚Äôs time to build a repository to contain them. There 
are many tools you can use to do that, including the official debian package archiving tool
known as <code>dak</code>, but if you want a personal repository without too much hassle, it‚Äôs better if you
use <code>reprepro</code>. I won‚Äôt go to full length on that here, <a href="http://www.debian-administration.org/article/286/Setting_up_your_own_APT_repository_with_upload_support">but instead I will lead you to a very
good guide to do so if you so desire</a></p>

<h2 id="fedora">Fedora</h2>

<p>Building packages for fedora is a procedure similar to the debian one. Fedora however is more
convenient in one aspect: <a href="http://download.fedoraproject.org/pub/fedora/linux/releases/20/Fedora/source/iso/Fedora-20-source-DVD.iso">It allows you to download a DVD image with all the sources in <code>.rpm</code> form
ready for you to customize and rebuild to your tastes.</a></p>

<p>Apart from that, the usual procedure is the following:</p>

<ul>
  <li>Download the <code>SRPM</code> (source RPM) via any means. You could do that using the <code>yumdownloader</code> utility, likewise <code>yumdownloader $package_name</code>. To use <code>yumdownloader</code>, you need
to have <code>yum-utils</code> installed.</li>
  <li>After you have downloaded the <code>SRPM</code>, next you have to unpack it: <code>rpm -i $package_name</code></li>
  <li>Next up, you customize the package to your liking (patch the sources, etc)</li>
  <li>Finally, you <code>cd</code> to the <code>SPECS</code> folder, and then <code>rpmbuild -ba $package.spec</code></li>
</ul>

<p>Again the above mentioned steps may not be 100% correct. If you want to go down this route,
see the following links for more information:</p>

<ul>
  <li><a href="http://wiki.centos.org/HowTos/RebuildSRPM">Centos wiki: Rebuild SRPM how-to</a></li>
  <li><a href="http://www.cyberciti.biz/faq/yum-download-source-packages-from-rhn/">cyberciti: yum Download all Source Packages from RedHat</a></li>
  <li><a href="http://bradthemad.org/tech/notes/patching_rpms.php">bradthemad.org: How to patch and rebuild an RPM package</a></li>
  <li><a href="http://www.rpm.org/max-rpm/ch-rpm-build.html">rpm.org: Chapter 11. Building packages</a></li>
  <li><a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package">Fedora wiki: How to create an RPM package</a></li>
</ul>

<p>Next up, is the repository creation step. </p>

<ul>
  <li>To create a yum repository, you need to <code>yum install createrepo</code>. 
After that you need to create a directory to use as the repository, likewise
<code>mkdir /var/ftp/repo/Fedora/19/{SRPMS, i386,x86_64)</code>. </li>
  <li>After that you move your i386 packages to <code>/var/ftp/repo/Fedora/19/i386</code>, and the rest
of the packages to their respective folders.</li>
  <li>Next step is adding a configuration file to <code>/etc/yum.repos.d/</code> that describes your repository
to yum.</li>
</ul>

<p>Again, not definitive, and for more information, take a look at these links:</p>

<ul>
  <li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/sec-Yum_Repository.html">Redhat: Creating a yum repository</a></li>
  <li><a href="http://www.techrepublic.com/blog/linux-and-open-source/create-your-own-yum-repository">techrepublic: Creating your own yum repository</a></li>
  <li><a href="http://docs.fedoraproject.org/en-US/Fedora/14/html/Deployment_Guide/sec-Creating_a_Yum_Repository.html">Fedora documentation: Creating a yum repository</a></li>
</ul>

<h2 id="arch-linux">Arch Linux</h2>

<p><a href="https://www.archlinux.org/">Arch Linux</a>, at least in comparison to <code>.deb</code> and <code>.rpm</code> package
distribution families is very easy to customize to your liking. That‚Äôs to be expected though
as Arch Linux is a distribution that sells itself of the customization capabilities it offers to its user.</p>

<p>In essence, if you want to customize a package, the general process is this:</p>

<ul>
  <li>Download Arch tarball that contains the <code>PKGBUILD</code> file</li>
  <li>untar the tarball</li>
  <li>(Optional) download the upstream tarball referenced in the <code>PKGBUILD</code>, and modify it
 to your liking</li>
  <li>run <code>makepkg</code> in the folder containing the <code>PKGBUILD</code></li>
  <li>install (using pacman) the <code>.xz</code> file produced after the whole process is finished.</li>
</ul>

<p>In order to download the official {core | extra | community} packages, you need to run as root
<code>abs</code>. This will create a directory tree that contains the files required for building any package 
in the official repositories.</p>

<p>Next up, you can create a custom local repository with the <code>repo-add</code> tool, and then proceeding
with editing <code>/etc/pacman.conf</code> and adding an entry for your repository there. For more information:</p>

<ul>
  <li><a href="http://arch-stable.blogspot.gr/2012/02/make-your-own-local-repo-for-arch-linux.html">arch-stable: make your own local repo for arch linux</a></li>
  <li><a href="https://wiki.archlinux.org/index.php/makepkg">arch wiki: makepkg</a></li>
  <li><a href="https://wiki.archlinux.org/index.php/Pacman_tips">arch wiki: pacman tips</a></li>
  <li><a href="https://wiki.archlinux.org/index.php/Arch_Build_System">arch wiki: Arch Build System</a></li>
  <li><a href="https://wiki.archlinux.org/index.php/Pacman#Repositories">arch wiki: Pacman#Repositories</a></li>
</ul>

<h1 id="to-fork-or-not-to-fork">To fork or not to fork?</h1>

<p>Well, that‚Äôs not an easy question to answer. My opinion is that it‚Äôs extremely educational to
do a <strong><em>soft</em></strong> fork, clone the distribution‚Äôs core repository, and for some time maintain your own
distribution based on it, that is, update and customize all the repositories. Do that for some months,
then go back to using your distribution of choice now that you are enlightened with how it works
under the hood. The reason this is very educational is that it will teach you the ins and outs of
your distribution, teach you about <strong>all</strong> the software in it, how it integrates, what its role is.
It will teach you packaging which is a tremendously undervalued skill, as you can customize
your experience to your liking, and it will make you appreciate the effort going into maintaining
the distribution.</p>

<p>As for doing a <strong>hard</strong> fork, that is creating your own distribution, that you commit to maintaining
it for a long time, my opinion is that it‚Äôs simply not worth it. Maintaining a distribution, be it
by yourself, or with your friends, is a tremendous amount of work, that‚Äôs not worth it unless
you have other goals you want to achieve by that. If all you want to do is to customize your 
distribution of choice to your liking, then go ahead, learn packaging for it, customize-package
the applications you want, then create your own repo - but always track the upstream. Diverging
too much from the upstream is not worth the hassle, as you will end up spending more time
maintaining than using the distribution in the end.</p>

<h2 id="tldr">tl;dr:</h2>

<p>If you want to do a small scale, private fork in order to see what‚Äôs under the hood of your Linux
distro; by all means go ahead.</p>

<p>If you want to do a large scale, public fork, then take your time to calculate the effort, if it‚Äôs worth it,
and if you could just help the upstream distribution implement the features you want. </p>

  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2014/06/20/how-the-compiler/">How the Compiler, the Library and the Kernel Work - Part 3</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-20T20:49:00+03:00" pubdate data-updated="true">Jun 20<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <p>In the last part of this series, we talked about the compiler‚Äôs composition, including the assembler
and the linker. We showed what happens when the compiler runs, and what‚Äôs the output
of translation software such as <code>cc1</code> or <code>as</code> etc. In this final part of the series, we are going
to talk about the C library, how our programs interface with it, and how it interfaces with 
the kernel.</p>

<h1 id="the-c-standard-library">The C Standard Library</h1>

<p>The C Standard Library is pretty much a part of every UNIX like operating system. It‚Äôs basically
a collection of code, including functions, macros, type definitions etc, in order to provide facilities
such as string handling (<code>string.h</code>), mathematical computations (<code>math.h</code>), input and output
(<code>stdio.h</code>), etc.</p>

<p>GNU/Linux operating systems are generally using the <a href="http://www.gnu.org/software/libc/libc.html">GNU C Library implementation(GLIBC)</a>,
but it‚Äôs common to find other C libraries being used (especially in embedded systems) such as 
<a href="http://www.uclibc.org">uClibC</a>, <a href="http://sources.redhat.com/newlib">newlib</a>, or in the case
of Android/Linux systems <a href="https://android.googlesource.com/platform/bionic.git">Bionic</a>.
BSD style operating systems usually have their own implementation of a C library.</p>

<h2 id="so-how-does-one-use-the-c-standard-library">So, how does one ‚Äúuse‚Äù the C Standard Library?</h2>

<p>So, now that we are acquainted with the C Library, how do you make use of it, you ask? The answer is:
<strong>automagically</strong> :). Hold on right there; that‚Äôs not exactly a hyperbole. You see, when you
write a basic C program, you usually <code>#include &lt;some_header.h&gt;</code> and then continue with
using the code declared in that header. We have explained in the previous part of this series
that when we use a function, say <code>printf()</code>, in reality it‚Äôs the linker that does the hard work 
and allows us to use this function, by linking our program against the <code>libc</code>‚Äôs <code>so</code> (shared 
object). So in essence, when you need to use the C Standard Library, you just <code>#include</code>
headers that belong to it, and the linker will resolve the references to the code included.</p>

<p>Apart from the functions that are defined in the Standards however, a C Library might also
implement further functionality. For example, the Standards don‚Äôt say anything about networking.
As a matter of fact, most libraries today may implement not only what‚Äôs in the C Standards,
but may also choose to comply with the requirements of the POSIX C library, which is a superset
of the C Standard library.</p>

<h2 id="ok-and-how-does-the-c-library-manage-to-provide-these-services">Ok, and how does the C Library manage to provide these services?</h2>

<p>The answer to this question is simple: Some of the services that the library provides, it does so
without needing any sort of special privileges, being normal, userspace C code, while others
need to ask the Operating‚Äôs system Kernel to provide these facilities for the library.</p>

<p>How does it do so? By calling some functions exported by the kernel to provide certain functionality
 named <strong>system calls</strong>. System calls are the fundamental interface between a userspace
application and the Operating System Kernel. For example consider this:</p>

<p>You might have a program that has code like this at one point: <code>fd = open("log.txt", "w+");</code>. That
<code>open</code> function is provided by the C Library, but the C Library itself can not execute all of the
functionality that‚Äôs required to open a file, so it may call a <code>sys_open()</code> system call that will
ask the kernel to do what‚Äôs required to load the file. In this case we say that the library‚Äôs <code>open</code>
call acts as a wrapper function of the system call.</p>

<h1 id="epilogue">Epilogue</h1>

<p>In this final part of our series, we saw how our applications interface with the C Standard Library
available in our system, and how the Library itself interfaces with the Operating system kernel
to provide the required services needed by the userspace applications.</p>

<h2 id="further-reading">Further Reading:</h2>

<p>If you want to take a look at the System Call interface in the Linux Operating System, you could
always see the <a href="http://man7.org/linux/man-pages/man2/syscalls.2.html">man page for the Linux system calls</a></p>

  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2014/04/28/introduction-to-xv6-adding-a-new-system-call/">Introduction to Xv6: Adding a New System Call.</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-28T18:24:00+03:00" pubdate data-updated="true">Apr 28<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <h1 id="xv6-an-introduction">xv6: An introduction</h1>

<p>If you are like me, a low level pc programmer, it‚Äôs hard not to have heard
of <strong>xv6</strong>. <a href="http://pdos.csail.mit.edu/6.828/2012/xv6.html">xv6</a>, for those
who haven‚Äôt really heard of it, is a <em>UNIX version 6</em> clone, designed
at MIT to help teach operating systems. </p>

<p>The reasoning behind doing this was fairly simple: <a href="http://www.lemis.com/grog/Documentation/Lions/">Up until that point, MIT
had used John Lions‚Äô famous commentary on the Sixth Edition of UNIX</a>. But V6 was challenging due to a 
number of reasons. To begin with, it was written in a near ancient version
of C (pre K&amp;R), and apart from that, it contained PDP-11 assembly
(a legendary machine for us UNIX lovers, but ancient nonetheless), which
didn‚Äôt really help the students that had to study both PDP-11 and the
(more common) x86 architecture to develop another (exokernel) operating
system on. </p>

<p>So, to make things much more simpler, professors there decided to 
roll with a clone of UNIX version 6, that was x86 specific, 
written in ANSI C and supported multiprocessor machines.</p>

<p>For a student (or a programmer interested in operating systems), xv6 is 
a unique opportunity to introduce himself to kernel hacking and to the
architecture of UNIX like systems. At about 15k lines of code (iirc), 
including the (primitive) libraries, the userland and the kernel,
it‚Äôs very easy (or well, at least easier than production scale UNIX like
systems) to grok, and it‚Äôs also very easy to expand on. It also helps
tremendously that xv6 as a whole has magnificent documentation, not only
from MIT, but from other universities that have adopted xv6 for use in their
operating systems syllabus.</p>

<h2 id="an-introduction-to-ensidia-my-very-personal-xv6-fork">An introduction to Ensidia: my very personal xv6 fork</h2>

<p>When I first discovered xv6 I was ecstatic. For the reasons mentioned above
I couldn‚Äôt lose on the opportunity to fork xv6 and use it as a personal
testbed for anything I could feel like exploring or testing out.</p>

<p>As a matter of fact, when I first discovered xv6, <a href="https://github.com/NlightNFotis/Fotix">I had just finished 
implementing (the base of) my own UNIX like operating system, named fotix</a>, 
and the timing of my discovery was great. xv6 had done what I had done,
and also implemented most of what I was planning to work on fotix
(for example, elf file loading), and it was a solid base for further 
development. It also had a userland, which fotix at the time didn‚Äôt have.</p>

<p>After I forked xv6, I spent some time familiriazing myself with the code.
I also cleaned up the source code quite a bit, structuring the code in a 
BSD like folder structure, instead of having all of the code in the same 
folder and made various small scale changes. </p>

<p>After that for quite some time, I had left ensidia alone and didn‚Äôt touch
it much. However, I always felt like I wanted to develop it a bit more
and get to play with its code in interesting ways. I was trying to think of
a great way to get started with kernel hacking on it, in a simple way, to 
get more acquainted with the kernel, and found an interesting pdf with 
interesting project ideas for it. One of them was to add a system call.
I figured out that would be an interesting and quick hack, so hey, why not?</p>

<h1 id="getting-started-with-kernel-hacking-on-xv6-adding-the-system-call">Getting started with kernel hacking on xv6: Adding the system call.</h1>

<p>The system call I decided to introduce was the suggested one. It was
fairly simple sounding too. You have to <strong>introduce a new system call
that returns the number of total system calls that have taken place
so far</strong>. So let‚Äôs see how I went about implementing it:</p>

<h2 id="an-introduction-to-system-calls-in-xv6">An introduction to system calls in xv6</h2>

<p>First of all, we should provide some context about what system calls are,
how they are used, and how they are implemented in xv6.</p>

<p>A system call is a function that a userspace application will use, so as
to ask for a specific service to be provided by the operating system. For
instance with an <code>sbrk(n)</code> system call, a process can ask the kernel to
grow its heap space by n bytes. Another example is the well known <code>fork()</code>
system call in the UNIX world, that‚Äôs used to create a new process by 
cloning the caller process.</p>

<p>The way applications signal the kernel that they need that service is
by issueing a software <em>interrupt</em>. An <em>interrupt</em> is a signal generated
that notifies the processor that it needs to stop what its currently doing,
and handle the interrupt. This mechanism is also used to notify the processor
that information it was seeking from the disks is in some buffer, ready to
be extracted and processed, or, that a key was pressed in the keyboard. This
is called a hardware interrupt.</p>

<p>Before the processor stops to handle the interrupt generated, it needs to 
save the current state, so that it can resume the execution in this context
after the interrupt has been handled. </p>

<p>The code that calls a system call in xv6 looks like this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>initcode.S </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
# exec(init, argv)
 .globl start
 start:
   pushl $argv
   pushl $init
   pushl $0  // where caller pc would be
   movl $SYS_exec, %eax
   int $T_SYSCALL
</pre></div>
</div>
 </figure></notextile></div>

<p>In essence, it pushes the argument of the call to the stack, and puts
the system call number (in the above code, that‚Äôs <code>$SYS_exec</code>) into <code>%eax</code>.
The number is used to match the entry in an array that holds pointers to
all the system calls. After that, it generates a software interrupt, with
a code (in this case <code>$T_SYSCALL</code>) that‚Äôs used to index the interrupt
descriptor tables and find the appropriate interrupt handler. </p>

<p>The code that is specific to find the appropriate interrupt handler is
called <code>trap()</code> and is available in the file <code>trap.c</code>. If <code>trap()</code> check‚Äôs
out the trapnumber in the generated trapframe (a structure that represents
the processor‚Äôs state at the time that the trap happened) to be equal to
<code>T_SYSCALL</code>, it calls <code>syscall()</code> (the software interrupt handler)
 that‚Äôs available in <code>syscall.c</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>trap.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// This is the part of trap that</span>
<span class="comment">// calls syscall()</span>
<span class="directive">void</span>
trap(<span class="keyword">struct</span> trapframe *tf)
{
  <span class="keyword">if</span>(tf-&gt;trapno == T_SYSCALL){
    <span class="keyword">if</span>(proc-&gt;killed)
      exit();
    proc-&gt;tf = tf;
    syscall();
    <span class="keyword">if</span>(proc-&gt;killed)
      exit();
    <span class="keyword">return</span>;
  }
</pre></div>
</div>
 </figure></notextile></div>

<p><code>syscall()</code> is finally the function that checks out <code>%eax</code> to get the 
number of the system call (to index the array with the system 
call pointers), and execute the code corresponding to that system call.</p>

<p>The implementation of system calls in xv6 is under two files. The first one
is <code>sysproc.c</code>, and is the one containing the implementation of system calls
correspondent to processes, and <code>sysfile.c</code> that contains the implementation
of system calls regarding the file system.</p>

<h2 id="the-specific-implementation-of-the-numcalls-system-call">The specific implementation of the <code>numcalls()</code> system call</h2>

<p>To implement the system call itself is simple. I did so with a global variable
in <code>syscall.c</code> called <code>syscallnum</code>, that‚Äôs incremented everytime 
<code>syscall()</code>, calls a system call function, that is, the system call
is valid.</p>

<p>Next we just need a function, the system call implementation that returns
that number to the userspace program that asks for it. Below is the 
function itself, and <code>syscall()</code> after our change.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>sysproc.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// return the number of system calls that have taken place in</span>
<span class="comment">// the system</span>
<span class="predefined-type">int</span>
sys_numcalls(<span class="directive">void</span>)
{
    <span class="keyword">return</span> syscallnum;
}
</pre></div>
</div>
 </figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>syscall.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// The syscall() implementation after</span>
<span class="comment">// our change</span>
<span class="directive">void</span>
syscall(<span class="directive">void</span>)
{
  <span class="predefined-type">int</span> num;

  num = proc-&gt;tf-&gt;eax;
  <span class="keyword">if</span>(num &gt; <span class="integer">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {
    syscallnum++; <span class="comment">// increment the syscall counter</span>
    proc-&gt;tf-&gt;eax = syscalls[num]();
  } <span class="keyword">else</span> {
    cprintf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%d %s: unknown sys call %d</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>,
            proc-&gt;pid, proc-&gt;name, num);
    proc-&gt;tf-&gt;eax = -<span class="integer">1</span>;
  }
}
</pre></div>
</div>
 </figure></notextile></div>

<p>After that was done, the next few things that were needed to be done
were fairly straight forward. We had to add an index number for the new
system call in <code>syscall.h</code>, expose it to user proccesses via <code>user.h</code>,
and add a new macro to <code>usys.S</code> that defines an asm routine that calls
that specific system call, and change the makefile to facilitate our change
. After doing so we had to write a userspace testing program to test our changes.</p>

<p>The result after doing all this is below :)</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
cpu1: starting
cpu0: starting
init: starting sh
$ ls
.              1 1 512
..             1 1 512
README         2 2 2209
cat            2 3 9725
echo           2 4 9254
forktest       2 5 5986
grep           2 6 10873
init           2 7 9579
kill           2 8 9246
ln             2 9 9240
ls             2 10 10832
mkdir          2 11 9315
rm             2 12 9308
sh             2 13 16600
stressfs       2 14 9790
usertests      2 15 37633
wc             2 16 10207
zombie         2 17 9028
syscallnum     2 18 9144
console        3 19 0
$ syscallnum
The total number of syscalls so far is 643
$ syscallnum
The total number of syscalls so far is 705
$ syscallnum
The total number of syscalls so far is 767
$ syscallnum
The total number of syscalls so far is 829
</pre></div>
</div>
 </figure></notextile></div>

<h1 id="epilogue">Epilogue</h1>

<p>I usually end my blog posts with an epilogue. Although this is a post
that doesn‚Äôt necesarilly need one, <strong>I wanted to write one just to say to you
that you should try kernel hacking</strong>, <em>that is programming jargon for
programming an operating system kernel</em>, because it‚Äôs an experience that
undoubtedly will teach you a great deal of things about how your computer
actually works.</p>

<p>Last but not least, take a look at the ongoing work on <a href="https://github.com/NlightNFotis/Ensidia">Ensidia, my fork
of xv6</a>. To see this particular
work, take a look at the <code>syscall</code> branch.</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://zoo.cs.yale.edu/classes/cs422/2010/reference">CS422/522: Operating systems, Yale</a></li>
  <li><a href="http://zoo.cs.yale.edu/classes/cs422/2010/xv6-book/fscall.pdf">Chapter 8, File System calls, xv6 reference, Yale</a></li>
  <li><a href="http://zoo.cs.yale.edu/classes/cs422/2010/xv6-book/trap.pdf">Chapter 3, System calls, exceptions and interrupts, Yale</a></li>
  <li><a href="http://pdos.csail.mit.edu/6.828/2012/xv6/book-rev7.pdf">xv6 Documentation, MIT csail</a></li>
</ul>

  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2014/04/25/how-the-compiler/">How the Compiler, the Library and the Kernel Work - Part 2</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-25T18:27:00+03:00" pubdate data-updated="true">Apr 25<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <p>In the previous part of this little series, we talked about the compiler, and what it does 
with the header files, in our attempt to demistify their usage. In this part, I want to show you
what‚Äôs the compiler‚Äôs output, and how we create our file.</p>

<h1 id="the-compilers-composition">The compiler‚Äôs composition</h1>

<p>Generally speaking, a <em>compiler</em> belongs to a family of software called <strong>translators</strong>. 
A translator‚Äôs job is to read some source code in a source language, and generate (translate it to) 
some source code in a target language.</p>

<p>Now, you might think that most compilers you know don‚Äôt do that. You input a (source code) file, 
and you get a binary file, ready to run when you want it to. Yes that‚Äôs what it does, but it‚Äôs not
the compiler that does all this. If you remember from the last installment of this series,
when you call the compiler like <code>gcc some_file.c</code> or <code>clang some_file.c</code>, in essence you are
calling the compilation driver, with the file as a parameter. The compilation driver then calls
1) the preprocessor, 2) the (actual) compiler, 3) the assembler and last but not least the linker.
At least when it comes to gcc, these pieces of software are called <code>cpp</code>, <code>cc1</code>, 
<code>gas</code> (executable name is <code>as</code>)  and <code>collect2</code> (executable name is <code>ld</code>) respectively.</p>

<p>From that little software collection up top, that we call the compiler, we can easily take notice
of at least 3 (yeah, that‚Äôs right) translators, that act as we mentioned earlier, 
that is take some input in a source language, and produce some output to a target language.</p>

<p>The first is the preprocessor. The preprocessor accepts source code in C as a source language,
and produces source code again in C (as a target language), but with the output having various
elements of the source code resolved, such as header file inclusion, macro expansion, etc.</p>

<p>The second is the compiler. The compiler accepts (in our case) C source code, as a source language,
and translates it to some architecture‚Äôs assembly language. In my case, when I talk about the 
compiler, I‚Äôm gonna assume that it produces x86 assembly.</p>

<p>The last one, is the assembler, which accepts as input some machine‚Äôs architecture assembly
language, and produces what‚Äôs called binary, or object representation of it, that is it translates
the assembly mnemonics directly to the bytes they correspond to, in the target architecture.</p>

<p>At this point, one could also argue that the linker is also a translator, accepting binary, and 
translating it to an executable file, that is, resolving references, and fitting the binary code
on the segments of the file that is to be produced. For example, on a typical GNU/Linux system,
this phase produces the executable ELF file.</p>

<h1 id="the-actual-compilers-output-x86-assembly">The (actual) compiler‚Äôs output: x86 assembly.</h1>

<p>Before we go any further, I would like to show you what the compiler really creates:</p>

<p>For the typical hello world program we demonstrated in our first installment, the compiler
will output the following assembly code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>hello.S </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
        .file        &quot;hello.c&quot;
        .section        .rodata
.LC0:
        .string        &quot;Hello world!&quot;
        .text
        .globl        main
        .type        main, @function
main:
        pushq        %rbp
        movq        %rsp, %rbp
        subq        $16, %rsp
        movl        %edi, -4(%rbp)
        movq        %rsi, -16(%rbp)
        movl        $.LC0, %edi
        call        puts
        movl        $0, %eax
        leave
        ret
        .size        main, .-main
        .ident        &quot;GCC: (GNU) 4.8.2 20131212 (Red Hat 4.8.2-7)&quot;
        .section        .note.GNU-stack,&quot;&quot;,@progbits
</pre></div>
</div>
 </figure></notextile></div>

<p>To produce the above file, we had to use the following gcc invocation command:
<code>gcc -S -fno-asynchronous-unwind-tables -o hello.S hello.c</code>. 
We used <code>-fno-asynchronous-unwind-tables</code> to remove <code>.cfi</code> directives, which tell <code>gas</code> 
(the gnu assembler) to emit Dwarf Call Frame Information tags, which are used to reconstruct
a stack backtrace when a frame pointer is missing.</p>

<p>For more usefull compilation flags, to control the intermediary compilation flow, try these:</p>

<ul>
  <li><code>-E</code>: stop after preprocessing, and produce a *.i file</li>
  <li><code>-S</code>: we used this, stop after the compiler, and produce a *.s file</li>
  <li><code>-c</code>: stop after the assembler, and produce a *.o file.</li>
</ul>

<p>The default behaviour is to use none, and stop after the linker has run. If you want to run a 
full compilation and keep all the intermediate files, use the <code>-save-temps</code> flag.</p>

<h1 id="from-source-to-binary-the-assembler">From source to binary: the assembler.</h1>

<p>The next part of the compilation process, is the assembler. We have already discussed what
the assembler does, so here we are going to see it in practice. If you have followed so far,
you should have two files, a <code>hello.c</code>, which is the hello world‚Äôs C source code file,
and a <code>hello.S</code> which is what we created earlier, the compiler‚Äôs (x86) assembly output.</p>

<p>The assembler operates on that last file as you can imagine, and to see it running, and emit
binary, we need to invoke it like this: <code>as -o hello.bin hello.S</code>, and produces this:</p>

<pre><code>ELF\00\00\00\00\00\00\00\00\00\00&gt;\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\F0\00\00\00\00\00\00\00\00\00\00\00@\00\00\00\00\00@\00\00\00UH\89\E5H\83\EC\89}\FCH\89u\F0\BF\00\00\00\00\E8\00\00\00\00\B8\00\00\00\00\C9\C3Hello world!\00\00GCC: (GNU) 4.8.2 20131212 (Red Hat 4.8.2-7)\00\00.symtab\00.strtab\00.shstrtab\00.rela.text\00.data\00.bss\00.rodata\00.comment\00.note.GNU-stack\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00@\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\B8\00\00\00\00\00\000\00\00\00\00\00\00\00	\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00&amp;\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00`\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00,\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00`\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\001\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00`\00\00\00\00\00\00\00
\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\009\00\00\00\00\00\000\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00m\00\00\00\00\00\00\00-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00B\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\9A\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\9A\00\00\00\00\00\00\00R\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\B0\00\00\00\00\00\00\F0\00\00\00\00\00\00\00
\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00	\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\A0\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\F1\FF\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00	\00\00\00\00\00\00\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00hello.c\00main\00puts\00\00\00\00\00\00\00\00\00\00\00\00\00
\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00	\00\00\00\FC\FF\FF\FF\FF\FF\FF\FF
</code></pre>

<h1 id="last-but-not-least-the-linker">Last but not least: the linker</h1>

<p>We saw what the assembler emits, which is to say, binary code. However, that binary code
still needs further processing. To explain that, we need to go back a little.</p>

<p>In our first installment of the series, we said that when you call a function like <code>printf()</code>,
the compiler only needs its prototype to do type checking and ensure that you use it legally.
For that you include the header file <code>stdio.h</code>. But since that contains the function prototype only,
where is the source code for that function? Surely, it must be somewhere, since it executes 
successfully to begin with, but we haven‚Äôt met the source code for printf so far, so where is it?</p>

<p>The function‚Äôs source code is located in the <code>.so</code> (shared object) of the standard C library,
which in my system (Fedora 19, x64) is <code>libc-2.17.so</code>. I don‚Äôt want to expand on that further,
as I plan to do so on the next series installment, however, what we have said so far is enough
for you to understand the linker‚Äôs usage:</p>

<p>The linker resolves the undefined (thus far) reference to printf, by finding the reference to
the printf symbol and (in layman‚Äôs talk) 
making a pointer to point to it so that execution can jump to printf‚Äôs code
when we have to do that during our program‚Äôs execution.</p>

<p>To invoke the linker on our file, <a href="https://sourceware.org/binutils/docs-2.20/ld/Options.html#Options">at least according to it‚Äôs documentation</a>, 
we should do the following: <code>ld -o hello.out /lib/crt0.o hello.bin -lc</code>. Then we should
be able to run the file like this: <code>./hello.out</code>.</p>

<h1 id="epilogue">Epilogue</h1>

<p>That‚Äôs this end of this part 2 of my series that explains how your code turns into binary, and how
your computer (at least when it comes to the software side) runs it. In part 3, I am going to discuss
in greater length, the C library, and the kernel.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://stackoverflow.com/questions/3564752/what-is-cfi-and-lfe-in-assembly-code-produced-by-gcc-from-c-program">StackOverflow: What is .cfi and .LFE in assembly code produced by GCC from c++ program?</a></li>
  <li><a href="http://blog.lxgcc.net/?p=181">GCC front-end (1): driver vs. compiler</a></li>
  <li><a href="http://wiki.osdev.org/GAS">GAS</a></li>
  <li><a href="https://sourceware.org/binutils/docs-2.20/ld/"> ld: Binutils documentation</a></li>
</ul>

  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2014/02/23/my-linux-from-scratch-experience/">My Linux From Scratch Experience</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-23T20:59:00+02:00" pubdate data-updated="true">Feb 23<span>rd</span>, 2014</time>
        
      </p>
    
  </header>


  <p>The past two to three days, I have been busy with creating my very own Linux distribution
using the well known <a href="http://www.linuxfromscratch.org">Linux from Scratch</a>. This post is 
an accounting of my experience with the process, what I liked, what I did learn from that,
what was surprising to me and more.</p>

<h1 id="linux-from-scratch-an-introduction">Linux from Scratch: An introduction</h1>

<p>If you are here, then you most likely already know what <a href="http://www.linuxfromscratch.com/">linux from scratch</a>
is, but for the sake of completeness (or in the case that you don‚Äôt know what it is, but are
so keen on learning)  I will provide an introduction about it here.</p>

<p>Linux from scratch is a book (from now on, <em>lfs</em>), providing a series of steps that guide you to the creation of
a fully function GNU/Linux distribution. Although the original book creates a ‚Äúbarebones‚Äù
distribution, with only fundamental tools in it, the distribution created provides a fine
enviroment for further experimentation or customization. </p>

<p>Apart from the basic book, the lfs project also has 3-4 books to read if you want to extend
the basic system (such as blfs, Beyond Linux from Scratch) or if you want to automate the process,
create a distribution that is more secure, or how to cross-compile an lfs system for different machines.</p>

<h1 id="my-experience-with-building-lfs">My experience with building LFS</h1>

<h2 id="a-small-introduction-about-my-background">A small introduction about my background</h2>

<p>I have been a UNIX (-like) systems (full-time) user for about 2.5 years now. During that time
I had seen myself from being what you would call a Linux newbie, not knowing how to use
a system without a GUI installed (have I mentioned that Ubuntu was my favourite distribution) to being an arguably experienced UNIX programmer, trying to learn more about the
various aspects of UNIX systems, and delving deeper and deeper into them every day
(while also feeling pain if using something other than a UNIX like system).</p>

<p>During that time, I have learned about the Unix way of working with the system, using the shell and the system‚Äôs toolchain to write software and other wise manipulate the system. I
ditched my old knowledge about IDEs and GUIs, and set out to master the command line and the associated tools (Anecdote: I remember, when I first came from to Unix from Windows, to searching the net for a C/C++ IDE to do development.) I remember reading about
how people worked another way in Unix land, using an editor, and the shell to work, and I 
decided to force myself to learn to work that way. I still remember trying to use vim and gcc, 
and ending up liking this way better because it seemed a more natural way to interact with
the software development process, than using a ide and pressing the equivalent of a ‚Äúplay‚Äù
button, so that magic ensues for the next few seconds until I have a result. </p>

<p>Time has passed since then, and going through hours and hours of reading and working with
the system, I did learn quite a lot about it. My Google Summer of Code experience in 2013
expanded my system knowledge even further (that‚Äôs what you get when you have to work
with the system kernel, the C library and a compiler). </p>

<p>But in all that time, of using Unix like systems, I never had the chance to create one myself.
And although my background did allow me to know quite a few things of the inner workings
of a system like that, I never actually saw all these software systems combining in front
of my very eyes to create that beauty we know as a GNU/Linux distribution. And that left
me a bad taste, because I knew what was happening, but I wanted to see it happen right 
in front of my eyes. </p>

<p>Knowing about the existence of lfs, and not actually going through it also made matters worse
for me, as I knew that I could actually ‚Äúpatch‚Äù that knowledge gap of mine, but I never really
tried to do that. I felt that I was missing on a lot, and that lfs would be instrumental to my
understanding of a Linux system. Having gone through that some years ago, and getting
stuck at the very beginning had also created an innate fear in me, that it was something
that would be above my own powers.</p>

<p>Until two days ago, when I said to myself: ‚ÄúYou know what? I have seen and done a lot 
of things in a UNIX system. I am now much more experienced than I was when I last did it.
And I know I want to at least try it, even if it will only give me nothing but infinite confusion 
Because if I do manage to get it, I will learn so many more things, or at least get assured
that my preexisting knowledge was correct‚Äù And that thought was the greatest motive I had
to do that in a fairly long time.</p>

<p>So, I sat at my desk, grabbed a cup of coffee and off I went!</p>

<h2 id="the-process">The process</h2>

<h3 id="preparation-and-the-temporary-toolchain">Preparation and the temporary toolchain</h3>

<p>The book is itself several chapters long, each of which perform another ‚Äúbig step‚Äù in the
creation of the distribution. </p>

<p>The first few chapters are preparatory chapters, where you ensure the integrity of the 
building environment, and download any building dependencies you may be lacking,
create a new partition that will host the lfs system, and create the user account that
will do the building of the temporary toolchain.</p>

<p>The temporary toolchain building is a more exciting process. In essence
you compile and collect several pieces of software that will later be used
to compile the distribution‚Äôs toolchain and other software.</p>

<p>You start of with building binutils, and that is to get a working assembler and linker. 
After having a working assembler and linker, you proceed with compiling <code>gcc</code>.
Next on is unpacking the linux headers, so that you can compile (and link against them)
the glibc. </p>

<p>Having the basic parts of the toolchain compiled, you then proceed with installing other
software that is needed in the temporary toolchain, like <code>gawk</code>, <code>file</code>, <code>patch</code>, <code>perl</code>
etc.</p>

<h3 id="building-the-main-system">Building the main system</h3>

<p>After getting done with the temporary toolchain, you then <code>chroot</code> into the lfs partition.
You start of with creating the needed directories (like <code>/bin</code>, <code>/boot</code>, <code>/etc</code>, <code>/home</code> etc)
and then continue with building the distribution software, utilising the temporary toolchain.
For instance, you construct a new <code>gcc</code>, you compile <code>sed</code>, <code>grep</code>, <code>bzip</code>, the <code>shadow</code>
utility that manages the handling of passwords etc, all while making sure that things don‚Äôt
break, and running countless tests (that sometimes take longer than what the package
took to compile) to ensure that what you build is functional and reliable.</p>

<h3 id="final-configuration">Final configuration</h3>

<p>Next one on the list, is the various configuration files that reside in <code>/etc</code>, and the setup
of <code>sysvinit</code>, the distribution‚Äôs <code>init</code> system.</p>

<p>Last, but not least, you are compiling the linux kernel and setting up grub so that the
system is bootable.</p>

<p>At this point, if all has gone well, and you reset, you should boot into your new lfs system.</p>

<h1 id="what-did-i-gain-from-that">What did I gain from that?</h1>

<p>Building lfs was a very time consuming process for me. It must have taken about 7-8
hours at the very least. Not so much because of the compilation and testing (I was compiling
with <code>MAKEFLAGS='-j 4'</code> on a Core i5), but because I was didn‚Äôt complete some steps
correctly, and later needed to go back and redo them, along with everything that followed,
along with the time it took to research some issues, programs or various other things
before I did issue a command at the shell.</p>

<p>Now if I were to answer the question ‚ÄúWhat did I gain from that‚Äù, my answer would be
along the lines of ‚ÄúInfinite confusion, and some great insight at some points‚Äù.</p>

<p>To elaborate on that,  </p>

<ul>
  <li>lfs mostly served as a reassurance that indeed, what I did know
about the system was mostly correct. </li>
  <li>I did have the chance to see the distribution
get built right before my eyes, which was something I longed for a great amount of time.</li>
  <li>It did make me somewhat more familiar with the <code>configure &amp;&amp; make &amp;&amp; make install</code>
cycle</li>
  <li>It made me realise that the directories in the system are the simple result of a <code>mkdir</code> command, and that configuration files in the <code>/etc/folder</code> are handwritten plain files. (<em>yeah, I feel stupid about that one - I don‚Äôt know what I was expecting.</em> This was probably the result of the ‚Äúmagic involved‚Äù that the distro making process entailed for me)</li>
  <li>I got to see the specific software that is needed to create a distribution, and demonstrate to me how I can build it, customize that build, or even change that software to my liking </li>
  <li>And last but not least, something that nearly every lfs user says after a successful try:
I knew that package managers did a great many things in order to maintain the system, and that much
of the work I would normally have to do was done nearly automatically 
but boy, was I underestimating them. After lfs, I developed a new appreciation for a
good package manager.</li>
</ul>

<h1 id="epilogue">Epilogue</h1>

<p><em>Lfs was, for the most part, a great experience.</em> <strong>As a knowledge expander, it works great.</strong>
<strong>As a system that you keep and continue to maintain? I don‚Äôt know.</strong> I know that people have
done that in the past, but I decided against maintaining my build, as I figured it would be
very time consuming, and that if I ever wanted to gain the experience of maintaining a distro,
I would probably fork something like <a href="http://www.crux.nu">Crux</a>.</p>

<p>In the end if you ask me if I can recommend that to you, I will say that I‚Äôm not so sure.
<strong>It will provide you with some insight into the internals of a GNU/Linux distribution, but it 
won‚Äôt make you a better programmer as some people claim</strong> (most of the process revolves
around the <code>configure &amp;&amp; make &amp;&amp; make install</code> cycle, and some conf files handwriting).</p>

<p><strong>In the end, it is yourself who you should ask. Do you want that knowledge? Is it worth the hassle for you?
Do you want the bragging rights? Are you crazy enough to want to maintain it?</strong> 
<em>These are all questions that you get as many answers to them as the people you ask.</em></p>

  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2013/12/12/how-the-compiler/">How the Compiler, the Library and the Kernel Work - Part 1</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-12T16:13:00+02:00" pubdate data-updated="true">Dec 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <p>Before we get any further, it might be good if we provided some context.</p>

<h1 id="hello-world-again">Hello world. Again.</h1>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>helloworld.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="preprocessor">#include</span> <span class="include">&lt;stdio.h&gt;</span>

<span class="predefined-type">int</span>
main (<span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> **argv)
{
    printf (<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello world!</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);

    <span class="keyword">return</span> <span class="integer">0</span>;
}
</pre></div>
</div>
 </figure></notextile></div>

<p>Every user space (read: application) programmer, has written a hello world program. 
Only god knows how many times this program has been written. Yet, 
most programmers‚Äô knowledge of the program is limited to something along the lines of:</p>

<blockquote>
  <ul>
    <li>It sends the string passed as a parameter to the system to print.  </li>
    <li>It takes the printf function from stdio.h and prints the string</li>
  </ul>
</blockquote>

<p>and various other things, which are anywhere between plain wrong, or partially correct. </p>

<p>** So why not demistify the process? **</p>

<h1 id="enter-the-c-preprocessor">Enter the C preprocessor.</h1>

<p>You may have heard of the C Preprocessor. It‚Äôs the first stage of a c or c++ file compilation,
and it‚Äôs actually responsible for things such as:</p>

<ul>
  <li><strong>inclusion of header files</strong> (it does so by replacing
<code>#include &lt;header.h&gt;</code> with the content of this file, and the file it includes recursively),</li>
  <li><strong>macro expansion</strong>, such as the famous comparison of two numbers (a greater than b). In essence, if you define
 the following macro <code>#define gt(a, b) ((a &gt; b) ? 1 : 0)</code>, then in a statement such as this:</li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre> <span class="keyword">if</span> (gt (<span class="integer">5</span>, <span class="integer">3</span>)) printf (<span class="string"><span class="delimiter">&quot;</span><span class="content">The first parameter is greater than the second.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
</pre></div>
</div>
</div>

<p><code>gt (5, 3)</code> gets expanded to the macro definition, so after the preprocessor has run you end up with something like this:</p>

<div><div class="CodeRay">
  <div class="code"><pre> <span class="keyword">if</span> (((<span class="integer">5</span> &gt; <span class="integer">3</span>) ? <span class="integer">1</span> : <span class="integer">0</span>)) printf (<span class="string"><span class="delimiter">&quot;</span><span class="content">The first parameter is greater than the second.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
</pre></div>
</div>
</div>

<ul>
  <li><strong>conditional compilation</strong> (things such as: </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
<span class="preprocessor">#ifdef</span> WIN32 
    printf (<span class="string"><span class="delimiter">&quot;</span><span class="content">We are on windows</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>); 
<span class="preprocessor">#endif</span>
</pre></div>
</div>
 </figure></notextile></div>

<p>amongst others. You can see it for yourself. Write the hello world program, and pass it to cpp: <code>cpp hello_world.c</code></p>

<p>So now that we know what it does it‚Äôs time to demistify a common myth regarding it: <em>Some people believe
that the header files include the function to be called.</em>. <strong>That‚Äôs wrong.</strong> What it does include is 
<strong>function prototypes</strong> (and some type definitions, etc) <strong>only</strong>. It doesn‚Äôt include the body of the function
to be called.</p>

<p>Some people find that fact quite surprising, though, it isn‚Äôt, if you get to understand what the compiler
does with it.</p>

<h1 id="say-hello-to-the-compiler">Say hello to the compiler.</h1>

<p>Here we are gonna unmask another pile of misconceptions. First of all, some people think that when they call 
<code>gcc</code> on the command line they are actually calling the compiler. <strong>They are not.</strong> <em>In fact they are calling
the software commonly called <strong>the compilation driver</strong>, whose job is to run all the software needed to fully
turn source to binary, including preprocessors, the actual compiler, an assembler and finally the linker</em></p>

<p>Having said that, the actual compiler that‚Äôs getting called when you call <code>gcc</code> is called <code>cc1</code>. You may have seen it some times when the driver reports errors. Wanna take a look at it, to make sure I‚Äôm not lying to you? 
(Hint: I‚Äôm not!) Fair enough. Why don‚Äôt you type this in the command line: <code>gcc -print-prog-name=cc1</code>. It should tell you where the actual compiler is located in your system.</p>

<p>So now that we have this (misconception) out of our minds, we can continue with our analysis. Last time we talked
about it, we said that the header files include <strong>prototypes</strong> and not the whole function.</p>

<p>You may know that in C, you usually declare a function, before you use it. The primary reason for doing this
is to provide the compiler with the ability to perform <strong>type checking</strong>, that is to check that the arguments
passed are correct, both in number, and in type, and to verify that the returned value (assuming there is one)
is being used correctly. Below is a program that demonstrates the function prototype:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>prototype.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="preprocessor">#include</span> <span class="include">&lt;stdio.h&gt;</span>

<span class="predefined-type">int</span> add_nums (<span class="predefined-type">int</span> first, <span class="predefined-type">int</span> second);

<span class="predefined-type">int</span>
main (<span class="directive">void</span>)
{
    printf (<span class="string"><span class="delimiter">&quot;</span><span class="content">5 + 5 results in %d</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, add_nums (<span class="integer">5</span>, <span class="integer">5</span>));

    <span class="keyword">return</span> <span class="integer">0</span>;
}

<span class="predefined-type">int</span>
add_nums (<span class="predefined-type">int</span> first, <span class="predefined-type">int</span> second)
{
    <span class="keyword">return</span> first + second;
}
</pre></div>
</div>
 </figure></notextile></div>

<p>In this particular example, the prototype gives the compiler a wide variety of information. It tells it
that function <code>add_nums</code> takes two int arguments and returns an integer to the calling function. Now the
compiler can verify that I am passing correct arguments to it when I call it inside printf. If I don‚Äôt include
the function prototype, and do something slightly evil such as calling <code>add_nums</code> with <code>float</code> arguments then 
this might happen:</p>

<pre><code>5 + 4 results in 2054324224
</code></pre>

<p>Now that you know that the compiler (the real one) only needs the prototype and not the actual function code,
you may be wondering how the compiler actually compiles it if it doesn‚Äôt know it‚Äôs code.</p>

<p>Now is the time to bring down another missconception. The word <em>compiler</em> is just a fancy name for software
otherwise known as <em>translators</em>. A <em>translator‚Äôs</em> job is to get input and turn it from one language (source language) to a second language (target language), whatever that may be. Most of the times, when you compile software,
you compile it to run in your computer, which runs on a processor from the x86 architecture family of processors.
A processor is typically associated with an assembly language for that architecture (which is just human friendly
mnemonics for common processor tasks), so your <em>x86 computer runs x86 assembly</em> (ok that‚Äôs not 100% true, but for
simplicity‚Äôs sake at the moment, it should serve. We will see why it‚Äôs not true later.) So the compiler 
(in a typical translation) translates (compiles) your C source code to x86 assembly. 
You can see this by compiling your hello world example and passing the compiler the <code>-S</code> (which asks it to stop,
after x86 assembly is produced) parameter, likewise <code>gcc -S hello.c</code>.</p>

<h1 id="conclusion">Conclusion</h1>

<p>At this part, we saw how the compiler and the preprocessor work with our code, in an attempt to demistify the 
so called library calls. In the next part, we are going to study the assembler and the linker, and for the final
part the loader and the kernel.</p>

  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2013/09/02/gsoc-week-11-report/">GSOC Week 11 Report</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-02T09:25:00+03:00" pubdate data-updated="true">Sep 2<span>nd</span>, 2013</time>
        
      </p>
    
  </header>


  <h1 id="introduction">Introduction</h1>

<p>This week was spent investigating the runtime and debugging executables with gdb.
It was interesting in the sense that it provided me with some interesting
pieces of information. Without any further ado, let‚Äôs present our findings:</p>

<h2 id="my-findings">My findings</h2>

<p>Before starting out playing with libpthread, and glibc, I wanted to make sure
that the goruntime behaved the way I believed it behaved, and make some further
assurances about the goruntime. These assurances had to do with the total number
of goroutines and the total number of machine threads at various checkpoints
in the language runtime.  </p>

<ul>
  <li>The first thread in the program is initialised during <code>runtime_schedinit</code>.</li>
  <li>The number of m‚Äôs (kernel threads) is dependent on the number of goroutines.
The runtime basically attempts to create an equal amount of m‚Äôs to run the goroutines.
We can observe everytime a new goroutine is created, there is a number of calls
to initiate a new kernel thread.</li>
  <li>There are at least two kernel threads. One that supports the runtime (mainly the 
garbage collector) and one that executes the code of the go program.</li>
</ul>

<p>There is only one small piece of code in the goruntime that creates some sort of
confusion for me, and that is the code for a new m initialisation. Let me first
present the code that confuses me:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>gcc/libgo/runtime/proc.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>

M*
runtime_newm(<span class="directive">void</span>)
{

    ...
        mp = runtime_mal(<span class="keyword">sizeof</span> *mp);

    ...
        mcommoninit(mp);
        mp-&gt;g0 = runtime_malg(-<span class="integer">1</span>, nil, nil);

    ...
        <span class="keyword">if</span>(pthread_attr_init(&amp;attr) != <span class="integer">0</span>)
                runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_attr_init</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">if</span>(pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED) != <span class="integer">0</span>)
                runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_attr_setdetachstate</span><span class="delimiter">&quot;</span></span>);

    ...
}
</pre></div>
</div>
 </figure></notextile></div>

<p>I purposely compacted the function for brevity, as it only serves as a demonstration for a point.
Now, my confusion lies in the line <code>mp-&gt;g0 = runtime_malg(-1, nil, nil)</code>. It is a piece of code
that allocates memory for a new goroutine. Now I am ok with that, <strong>but</strong> what I do not understand
is that new kernel threads (m‚Äôs) are supposed to be pick and run a goroutine from the global 
goroutine pool - that is run an existing one, and not create a new one. Now, the <code>runtime_malg</code>
is given parameters that don‚Äôt initialise a new goroutine properly, but still, new memory
is allocated for a new goroutine, and is returned to <code>mp-&gt;g0</code> from runtime_malg.</p>

<p>Assuming I have not misunderstood something, and I am not mistaken (which is kind of likely), 
this is behavior that could lead to a number of questions and/or problems. For instance,
what happens to the goroutine created by <code>runtime_malg</code>? Is it killed after the m is assigned
a new goroutine to execute? Is it parked on the goroutine global list? Is it just ignored?
Does it affect the runtime scheduler‚Äôs goroutine count? This is the last thing I feel I wanna
clear out regarding gccgo‚Äôs runtime.</p>

<h2 id="gdb">gdb</h2>

<p>For this week, I also run the executables created by gccgo through gdb. It was a fertile attempt
that, most of the time, confirmed my findings in the goruntime. It also provided us with some
other nice pieces of information regarding the crashing of goroutines, but also left me with a 
question.</p>

<p>The code in question that I run through gdb is this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>goroutine.go </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fmt</span><span class="delimiter">&quot;</span></span>

<span class="keyword">func</span> say(s <span class="predefined-type">string</span>) {
    <span class="keyword">for</span> i := <span class="integer">0</span>; i &lt; <span class="integer">5</span>; i++ {
        fmt.Println(s)
    }
}

<span class="keyword">func</span> main() {
    fmt.Println(<span class="string"><span class="delimiter">&quot;</span><span class="content">[!!] right before a go statement</span><span class="delimiter">&quot;</span></span>)
    <span class="keyword">go</span> say(<span class="string"><span class="delimiter">&quot;</span><span class="content">world</span><span class="delimiter">&quot;</span></span>)
    say (<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>)
}
</pre></div>
</div>
 </figure></notextile></div>

<p>Your very typical hello world like goroutine program. Now, setting a break point in main 
(not the program‚Äôs main, that‚Äôs <code>main.main</code>. <code>main</code> as far as the runtime is concerned is
 the runtime entry point, in <code>go-main.c</code>) and running it through gdb yields the following
results:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
Breakpoint 1, main () at ../../../gcc_source/libgo/runtime/go-main.c:52
52 runtime_check ();
2:  __pthread_total = 1
1: runtime_sched.mcount = 0
(gdb) next
53 runtime_args (argc, (byte **) argv);
2: __pthread_total = 1
1: runtime_sched.mcount = 0
54 runtime_osinit ();
2: __pthread_total = 1
1: runtime_sched.mcount = 0
63: runtime_schedinit ();
2: __pthread_total = 1
1: runtime_sched.mcount = 1
</pre></div>
</div>
 </figure></notextile></div>

<p>Up until now, nothing unexpected. The kernel thread is registered with the runtime scheduler
during its initialisation process in <code>runtime_schedinit</code> and that‚Äô why the <code>runtime_sched.mcount</code>
is reported to be zero many times before schedinit is run.</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
68 __go_go (mainstart, NULL);
2: __pthread_total = 1
1: runtime_sched.mcount = 1
(gdb) display runtime_sched.gcount
3: runtime_sched.gcount = 0
</pre></div>
</div>
 </figure></notextile></div>

<p>That too is ok, because a new goroutine is registered with the scheduler during the call to
<code>__go_go</code>. Now I am gonna fast forward a bit, to a more interesting point.</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
...
[DEBUG] (in runtime_gogo) new goroutine's status is 2
[DEBUG] (in runtime_gogo) number of goroutines now is 2
[New Thread 629.30]

Program received SIGTRAP, Trace/breakpoint trap.
0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
3: runtime_sched.gcount = 2
2: __pthread_total = 2
1: runtime_sched.mcount = 2
(gdb) info threads
 Id   Target  Id       Frame
 6    Thread  629.30   0x08048eb7 in main.main () at goroutine.go:12
 5    Thread  629.29   0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
*4    Thread  629.28   0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
&lt;div class='bogus-wrapper'&gt;&lt;notextile&gt;&lt;figure class='code'&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class='line-number'&gt;1&lt;/span&gt;
&lt;span class='line-number'&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;td class='code'&gt;&lt;pre&gt;&lt;code class=''&gt;&lt;span class='line'&gt;This is getting weird. I mean, libpthread is reporting that 2 threads are active,
&lt;/span&gt;&lt;span class='line'&gt;but gdb reports that 3 are active. Anyway, let's continue:
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;&lt;/notextile&gt;&lt;/div&gt;
[DEBUG] (in runtime_stoptheworld) stopped the garbage collector
[DEBUG] (in runtime_starttheworld) starting the garbage collector
[DEBUG] (in runtime_starttheworld) number of m's now is: 2
[DEBUG] (in runtime_starttheworld) [note] there is already one gc thread
[!!] right before a go statement

Program received signal SIGTRAP, Trace/breakpoint trap.
0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
3: runtime_sched.gcount = 2
2: __pthread_total = 2
1: runtime_sched.mcount = 2
(gdb) continue
... (output omitted by me for brevity)

[DEBUG] (in runtime_newm) Right before the call to pthread_create.
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
[New Thread 629.31]

Program received signal SIGABRT, Aborted.
0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
3: runtime_sched.gcount = 3
2: __pthread_total = 2
1: runtime_sched.mcount = 3
</pre></div>
</div>
 </figure></notextile></div>

<p>Oh my goodness. From a first glance, this seems to be a very serious inconsistency between libpthread and the goruntime.
At this point, the go scheduler reports 3 threads (3 registered threads, that means 
that flow of execution has passed <code>mcommoninit</code>, the kernel thread initialisation function
which also registers the kernel thread with the runtime_scheduler) whereas libpthread reports 2 threads.</p>

<p><strong>But WAIT! Where are you going? Things are about to get even more interesting!</strong></p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
(gdb) info threads
 Id   Target  Id       Frame
 7    Thread  629.31   0x01f4da00 in entry_point () from /lib/i386-gnu/libpthread.so.0.3
 6    Thread  629.30   0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
 5    Thread  629.29   0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
*4    Thread  629.28   0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
</pre></div>
</div>
 </figure></notextile></div>

<p>GDB reports 4 threads. Yes, 4 threads ladies and gentlemen. Now take a look closely.
3 threads are in the same frame, with the one with id 4 being the one currently executed.
And there is also a pattern. <code>0x01da48ec</code> is the value of the <code>eip</code> register for all 3 of them.</p>

<p>That‚Äôs one thing that is for certain. Now I already have an idea. Why not change
the current thread to the one with id 7? I‚Äôm sold to the idea, let‚Äôs do this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
(gdb) thread 7
[Switching to thread 7 (Thread 629.31)]
#0  0x01f4da00 in entry_point () from /lib/i386-gnu/libpthread.so.0.3
(gdb) continue
Continuing.

Program received signal SIGABRT, Aborted.
[Switching to Thread 629.28]
0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
3: runtime_sched.gcount = 3
2: __pthread_total = 2
1: runtime_sched.mcount = 3
(gdb) info threads
 Id   Target  Id       Frame
 7    Thread  629.31   0x01dc08b0 in ?? () from /lib/i386-gnu/libc.so.0.3
 6    Thread  629.30   0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
 5    Thread  629.29   0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
*4    Thread  629.28   0x01da48ec in ?? () from /lib/i386-gnu/libc.so.0.3
</pre></div>
</div>
 </figure></notextile></div>

<p>Damn. But I am curious. What‚Äôs the next value to be executed?</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
(gdb) x/i $eip
=&gt; 0x1da48ec: ret
</pre></div>
</div>
 </figure></notextile></div>

<p>And what is the next value to be executed for the thread with id 7?</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
(gdb) x/i $eip
=&gt; 0x1dc08b0: call *%edx
</pre></div>
</div>
 </figure></notextile></div>

<h1 id="conclusion">Conclusion</h1>

<p>Apparently, there is still much debugging left to checkout what is really happening.
But we have got some leads in the right direction, that hopefully will lead us to 
finally finding out where the problem lies, and correct it.</p>

<p>Most importantly, in my immediate plans, before iI start playing around with libpthread
is to attempt the same debugging run on the same code, under linux (x86). Seeing as
go is clean on linux, it would provide some clues as to what the expected results 
should be, and where the execution differentiates substantially, a clue
that might be vital to finding the problem.</p>

  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2013/08/26/gsoc-week-10-report/">GSOC Week 10 Report</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-26T09:00:00+03:00" pubdate data-updated="true">Aug 26<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <h1 id="introduction">Introduction</h1>

<p>This week was spent attempting to debug the gccgo runtime via print statements. There were many things
that I gained from this endeavour. The most significant of which, is the fact that I have got a great
deal of information regarding the bootstrapping of a go process. Let‚Äôs proceed into presenting this 
week‚Äôs findings, shall we?</p>

<h1 id="findings">Findings</h1>

<h2 id="the-process-bootstrapping-sequence">The process bootstrapping sequence</h2>

<p>The code that begins a new go-process is conveniently located in a file called <code>go-main.c</code>, the most significant
part of which is the following:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>go-main.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="predefined-type">int</span>
main (<span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> **argv)
{
  runtime_check ();
  runtime_args (argc, (byte **) argv);
  runtime_osinit ();
  runtime_schedinit ();
  __go_go (mainstart, <span class="predefined-constant">NULL</span>);
  runtime_mstart (runtime_m ());
  abort ();
}

<span class="directive">static</span> <span class="directive">void</span>
mainstart (<span class="directive">void</span> *arg __attribute__ ((unused)))
{
  runtime_main ();
}
</pre></div>
</div>
 </figure></notextile></div>

<p>The process is as follows:</p>

<ul>
  <li>First <code>runtime_check</code> runs and registers the os_Args and syscall_Envs as runtime_roots with the garbage collector. I am still investigating what this function exactly is doing, but it seems like some early initialisation of the garbage collector</li>
  <li>Secondly, <code>runtime_args</code> is run. It‚Äôs job is to call a specific argument handler for the arguments passed to <code>main</code>.</li>
  <li>Thirdly, <code>runtime_osinit</code> is run, whose job is to call the lowlevel _CPU_COUNT function, to get the number of CPUs (in a specific data structure that represents a set of CPUs)</li>
  <li>After that, <code>runtime_schedinit</code> is run, whose job is to create the very first goroutine (g) and system thread (m), and continues with parsing the command line arguments, and the environment variables. After that it sets the maximum number of cpus that are to be used (via <code>GOMAXPROCS</code>), runs the first goroutine, and does some last pieces of the scheduler‚Äôs initialisation.</li>
  <li>Following <code>runtime_schedinit</code>, <code>__go_go</code> is run, a function whose purpose is to create a new queue, tell it to execute the function that is passed to it as the first parameter, and then queue the goroutine in the
global ready-to-run goroutine pool.</li>
  <li>Last but not least, <code>runtime_mstart</code> runs, which seems to be starting te execution of the kernel thread created during <code>runtime_schedinit</code>.</li>
</ul>

<p>The very last piece of code that is run (and most probably the most important) is <code>runtime_main</code>. Remember that this is passed as a parameter to a goroutine created during the <code>__go_go</code> call, and its job is to mark the goroutine that called it as <em>the main os thread</em>, to initialise the sceduler, and create a goroutine whose job is to release unused memory (from the heap) back to the OS.
It then starts executing the process user defined instructions (the code the programmer run) via a call to a
macro that directs it to <code>__go_init_main</code> in the assembly generated by the compiler.</p>

<p><code>Runtime_main</code> is also the function that terminates the execution of a go process, with a call to <code>runtime_exit</code>
which seems to be a macro to the <code>exit</code> function.</p>

<h2 id="other-findings">Other findings</h2>

<p>During our debugging sessions we found out that the total count of kernel threads that are running in a simple program is at least two.
The first one is the bootstrap M, (the one initialised during the program‚Äôs initialisation, inside <code>runtime_schedinit</code>) and at least another one, (I am still invistigating the validity of the following claim) 
created to be used by the garbage collector. </p>

<p>A simple go program such as one doing arithmetic or printing a helloworld like message evidently has no issue
running.
The issues arrise when we use a <code>go statement</code>. With all our debugging messages activated, this is how a simple
go program flows:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
root@debian:~/Software/Experiments/go# ./a.out
[DEBUG] (in main) before runtime_mcheck is run
[DEBUG] (in main) before runtime_args is run
[DEBUG] (in main) before runtime_osinit is run
[DEBUG] (in main) before runtime_schedinit is run
[DEBUG] (in main) before runtime_mstart is run
[DEBUG] (in runtime_mstart) right before the call to runtime_minit
[DEBUG] (in mainstart) right before the call to runtime_main
[DEBUG] (in runtime_main) Beginning of runtime_main
[DEBUG] (start of runtime_newm) Total number of m's is 1
[DEBUG] (in runtime_newm) Preparing to create a new thread
[DEBUG] (in runtime_newm) Right before the call to pthread_create
[DEBUG] (in runtime_newm) pthread_create returned 0
[DEBUG] (in runtime_mstart) right before the call to runtime_minit
[DEBUG] (end of runtime_newm) Total number of m's is 2
Hello, fotis
[DEBUG] (in runtime_main) Right before runtime_exit
</pre></div>
</div>
 </figure></notextile></div>

<p>And this is how a goroutine powered program fails:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
root@debian:~/Software/Experiments/go# ./a.out
[DEBUG] (in main) before runtime_mcheck is run
[DEBUG] (in main) before runtime_args is run
[DEBUG] (in main) before runtime_osinit is run
[DEBUG] (in main) before runtime_schedinit is run
[DEBUG] (in main) before runtime_mstart is run
[DEBUG] (in runtime_mstart) right before the call to runtime_minit
[DEBUG] (in mainstart) right before the call to runtime_main
[DEBUG] (in runtime_main) Beginning of runtime_main
[DEBUG] (start of runtime_newm) Total number of m's is 1
[DEBUG] (in runtime_newm) Preparing to create a new thread
[DEBUG] (in runtime_newm) Right before the call to pthread_create
[DEBUG] (in runtime_newm) pthread_create returned 0
[DEBUG] (in runtime_mstart) right before the call to runtime_minit
[DEBUG] (end of runtime_newm) Total number of m's is 2
[DEBUG] (start of runtime_new) Total number of m's is 2
[DEBUG] (in runtime_newm) Preparing to create a new thread.
[DEBUG] (in runtime_newm) Right before the call to pthread_create
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</pre></div>
</div>
 </figure></notextile></div>

<h1 id="work-for-the-next-week">Work for the next week</h1>

<p>I will of course continue to print debug until I have knowledge of the exact flow of execution in the go
runtime. Right now I have very good knowledge of the flow, but there are some things that I need to sort out.
For instance it is not exactly clear to me why we call certain functions, or what they are supposed to be doing at certain parts. After I sort this out,  I also plan to start debugging the libpthread to see what‚Äôs libpthreads status
during a hello world like program, and during a goroutine powered program, to get to see if we get
to find something interesting in libpthread (like how many threads does libpthread report against how
many the goruntime reports)</p>


  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2013/08/19/gsoc-week-9-partial-report/">GSOC Week 9 (Partial) Report</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-19T11:35:00+03:00" pubdate data-updated="true">Aug 19<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <p>This week was revolving around the print debugging in the gccgo runtime in search
for clues regarding the creation of new threads under the goruntime, so as to see
if there is something wrong with the runtime itself, or the way the runtime 
interacts with the libpthread.</p>

<h2 id="partial-presentation-of-findings">(partial presentation of) findings</h2>

<p>During print debugging the gccgo runtime, I didn‚Äôt notice anything abnormal or 
unusual so far. For example, the code that does trigger the assertion failure
seems to work at least once, since <code>pthread_create()</code> returns <code>0</code> at least once.</p>

<p>This is expected behavior, since we already have stated that there is at least
one <code>M</code> (kernel thread) created at the initialisation of the program‚Äôs runtime.</p>

<p>If however, we try to use a <em>go statement</em> in our program, to make usage of a 
goroutine, the runtime still fails at the usual assertion fail, however the 
output of the program is this:</p>

<div><div class="CodeRay">
  <div class="code"><pre>root@debian:~/Software/Experiments/go# ./a.out
[DEBUG] pthread_create returned 0
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</pre></div>
</div>
</div>

<p>The above output can give us some pieces of information:</p>

<ul>
  <li><code>pthread_create()</code> is called at least once.</li>
  <li>it executes successfuly and without errors - libpthread code suggests that 0 is returned upon successful execution and creation of a thread</li>
  <li>However the assertion is still triggered, which we know it‚Äôs getting triggered during thread creation.</li>
</ul>

<p>The second bullet point is also being supported by the fact that even if you exe
cute something as simple as hello world in go, a new M is created, so you get
something along the lines of this as an output:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
root@debian:~/Software/Experiments/go# ./a.out
[DEBUG] pthread_create returned 0
Hello World!
root@debian:~/Software/Experiments/go#
</pre></div>
</div>
 </figure></notextile></div>

<p>There is however something that the above piece of code doesn‚Äôt tell us, 
but it would be useful to know: <em>How many times did we create a new thread?</em>
So we modify our gcc‚Äôs source code to see how many times the runtimes 
attempts to create a new kernel thread (M). This is what we get out of it:</p>

<div><div class="CodeRay">
  <div class="code"><pre>root@debian:~/Software/Experiments/go# ./a.out
[DEBUG] Preparing to create a new thread.
[DEBUG] pthread_create returned 0
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
[DEBUG] Preparing to create a new thread.
aborted.
</pre></div>
</div>
</div>

<p>The code at this point in the runtime is this:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="comment">// Create a new m.  It will start off with a call to runtime_mstart.</span>
M*
runtime_newm(<span class="directive">void</span>)
{
    M *mp;
    pthread_attr_t attr;
    pthread_t tid;
    size_t stacksize;
    sigset_t clear;
    sigset_t old;
    <span class="predefined-type">int</span> ret;

<span class="comment">#if 0
    static const Type *mtype;  // The Go type M
    if(mtype == nil) {
        Eface e;
        runtime_gc_m_ptr(&amp;e);
        mtype = ((const PtrType*)e.__type_descriptor)-&gt;__element_type;
    }
#endif</span>

    <span class="comment">// XXX: Added by fotis for print debugging.</span>
    printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">[DEBUG] Preparing to create a new thread.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)

    mp = runtime_mal(<span class="keyword">sizeof</span> *mp);
    mcommoninit(mp);
    mp-&gt;g0 = runtime_malg(-<span class="integer">1</span>, nil, nil);

    <span class="keyword">if</span>(pthread_attr_init(&amp;attr) != <span class="integer">0</span>)
        runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_attr_init</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">if</span>(pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED) != <span class="integer">0</span>)
        runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_attr_setdetachstate</span><span class="delimiter">&quot;</span></span>);

    <span class="comment">// &lt;http://www.gnu.org/software/hurd/open_issues/libpthread_set_stack_size.html&gt;</span>
<span class="preprocessor">#ifdef</span> __GNU__
    stacksize = StackMin;
<span class="preprocessor">#else</span>
    stacksize = PTHREAD_STACK_MIN;

    <span class="comment">// With glibc before version 2.16 the static TLS size is taken</span>
    <span class="comment">// out of the stack size, and we get an error or a crash if</span>
    <span class="comment">// there is not enough stack space left.  Add it back in if we</span>
    <span class="comment">// can, in case the program uses a lot of TLS space.  FIXME:</span>
    <span class="comment">// This can be disabled in glibc 2.16 and later, if the bug is</span>
    <span class="comment">// indeed fixed then.</span>
    stacksize += tlssize;
<span class="preprocessor">#endif</span>

    <span class="keyword">if</span>(pthread_attr_setstacksize(&amp;attr, stacksize) != <span class="integer">0</span>)
        runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_attr_setstacksize</span><span class="delimiter">&quot;</span></span>);

    <span class="comment">// Block signals during pthread_create so that the new thread</span>
    <span class="comment">// starts with signals disabled.  It will enable them in minit.</span>
    sigfillset(&amp;clear);

<span class="preprocessor">#ifdef</span> SIGTRAP
    <span class="comment">// Blocking SIGTRAP reportedly breaks gdb on Alpha GNU/Linux.</span>
    sigdelset(&amp;clear, SIGTRAP);
<span class="preprocessor">#endif</span>

    sigemptyset(&amp;old);
    sigprocmask(SIG_BLOCK, &amp;clear, &amp;old);
    ret = pthread_create(&amp;tid, &amp;attr, runtime_mstart, mp);

    <span class="comment">/* XXX: added for debug printing */</span>
    printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">[DEBUG] pthread_create() returned %d</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, ret);

    sigprocmask(SIG_SETMASK, &amp;old, nil);

    <span class="keyword">if</span> (ret != <span class="integer">0</span>)
        runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_create</span><span class="delimiter">&quot;</span></span>);

    <span class="keyword">return</span> mp;
}
</pre></div>
</div>
</div>

<p>We can deduce two things about our situation right now:</p>

<ul>
  <li>There is <strong>at least one</strong> thread successfully created, and there is an attempt
to create another one.</li>
  <li>The second time, there is a failure before pthread_create is called.</li>
</ul>

<h2 id="continuation-of-work">Continuation of work.</h2>

<p>I have been following this course of path the last week. I presented
some of my findings, and hope to soon be able to write an exhaustive
report on what exactly it is that causes the bug.</p>

  
  


    </article>
  
  
    <article class="post">
      <div class="sharing-box">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://NlightNFotis.github.io/index.html" data-via="NlightNFotis" data-counturl="http://NlightNFotis.github.io/index.html" data-size="large">Tweet</a>
  
  
  
</div>

      
  <header>
    
      <h2 class="entry-title">
        
        <a href="/blog/2013/08/12/gsoc-week-8-partial-report/">GSOC Week 8 (Partial) Report</a>
        
      </h2>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-12T10:27:00+03:00" pubdate data-updated="true">Aug 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <p>This week was spent studying the go language‚Äôs runtime and studying the behaviour of various go programs when executed under the Hurd. I learnt a variety of new things, and got some 
new clues about the problem.</p>

<h2 id="the-new-libgo-clues">The new libgo clues</h2>

<p>I already know that <em>M‚Äôs are the ‚Äúreal‚Äù kernel schedulable threads</em> and <em>G‚Äôs are the go runtime managed ones (goroutines)</em>. Last time I had gone through the go runtime‚Äôs code I had noticed that neither of them get created, so there must be an issue with thread creation. <strong>But since there is at least one of each created during the program‚Äôs initialization, how come
most programs are able to run, and issues present themselves when we manually attempt to run a goroutine?</strong></p>

<p>I will admit that the situation looks strange. So I decided to look more into it. Before we go any further, I have to embed the issues I had when I run goroutine powered programs under the Hurd.</p>

<div><div class="CodeRay">
  <div class="code"><pre>root@debian:~/Software/Experiments/go# ./a.out
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</pre></div>
</div>
</div>

<p><code>__pthread_create_internal</code> is a libpthread function that gets called when a new posix thread is instanciated. So we know that when we call a goroutine, apart from the goroutine,
there is at least one kernel thread created, otherwise, if a new goroutine was created, and not a new kernel thread (M) why wasn‚Äôt it matched with an existing kernel thread
(remember there is at least one).</p>

<p>That made me look into the go runtime some more. I found a lot of things, that I can not enumerate here, but amongst the most interesting ones, was the following piece of code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>proc.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>

<span class="comment">// Create a new m.  It will start off with a call to runtime_mstart.</span>
M*
runtime_newm(<span class="directive">void</span>)
{
        M *mp;
        pthread_attr_t attr;
        pthread_t tid;
        size_t stacksize;
        sigset_t clear;
        sigset_t old;
        <span class="predefined-type">int</span> ret;

<span class="comment">#if 0
        static const Type *mtype;  // The Go type M
        if(mtype == nil) {
                Eface e;
                runtime_gc_m_ptr(&amp;e);
                mtype = ((const PtrType*)e.__type_descriptor)-&gt;__element_type;
        }
#endif</span>

        mp = runtime_mal(<span class="keyword">sizeof</span> *mp);
        mcommoninit(mp);
        mp-&gt;g0 = runtime_malg(-<span class="integer">1</span>, nil, nil);

        <span class="keyword">if</span>(pthread_attr_init(&amp;attr) != <span class="integer">0</span>)
                runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_attr_init</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">if</span>(pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED) != <span class="integer">0</span>)
                runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_attr_setdetachstate</span><span class="delimiter">&quot;</span></span>);

        stacksize = PTHREAD_STACK_MIN;

        <span class="comment">// With glibc before version 2.16 the static TLS size is taken</span>
        <span class="comment">// out of the stack size, and we get an error or a crash if</span>
        <span class="comment">// there is not enough stack space left.  Add it back in if we</span>
        <span class="comment">// can, in case the program uses a lot of TLS space.  FIXME:</span>
        <span class="comment">// This can be disabled in glibc 2.16 and later, if the bug is</span>
        <span class="comment">// indeed fixed then.</span>
        stacksize += tlssize;

        <span class="keyword">if</span>(pthread_attr_setstacksize(&amp;attr, stacksize) != <span class="integer">0</span>)
                runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_attr_setstacksize</span><span class="delimiter">&quot;</span></span>);

        <span class="comment">// Block signals during pthread_create so that the new thread</span>
        <span class="comment">// starts with signals disabled.  It will enable them in minit.</span>
        sigfillset(&amp;clear);

<span class="preprocessor">#ifdef</span> SIGTRAP
        <span class="comment">// Blocking SIGTRAP reportedly breaks gdb on Alpha GNU/Linux.</span>
        sigdelset(&amp;clear, SIGTRAP);
<span class="preprocessor">#endif</span>

        sigemptyset(&amp;old);
        sigprocmask(SIG_BLOCK, &amp;clear, &amp;old);
        ret = pthread_create(&amp;tid, &amp;attr, runtime_mstart, mp);
        sigprocmask(SIG_SETMASK, &amp;old, nil);

        <span class="keyword">if</span> (ret != <span class="integer">0</span>)
                runtime_throw(<span class="string"><span class="delimiter">&quot;</span><span class="content">pthread_create</span><span class="delimiter">&quot;</span></span>);

        <span class="keyword">return</span> mp;
}
</pre></div>
</div>
 </figure></notextile></div>

<p>This is the code that creates a new kernel thread. Notice the line <code>ret = pthread_create(&amp;tid, &amp;attr, runtime_mstart, mp);</code>. It‚Äôs obvious that it creates a new kernel thread,
so that explains why we get the specific error. But what is not explained is that since we do have at least one in program startup, why is this specific error only triggered when
we manually create a go routine?</p>

<h2 id="go-programs-under-the-hurd">Go programs under the Hurd</h2>

<p>Apart from studying Go‚Äôs runtime source code, I also run some experiments under the Hurd. I got some very weird results that I am investigating, but I would like to share nonetheless.
Consider the following piece of code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption class="code-header" style="margin-bottom:-5px;"><span>hellogoroutines.go </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fmt</span><span class="delimiter">&quot;</span></span>

<span class="keyword">func</span> say(s <span class="predefined-type">string</span>) {
    <span class="keyword">for</span> i := <span class="integer">0</span>; i &lt; <span class="integer">5</span>; i++ {
        fmt.Println(s)
    }
}

<span class="keyword">func</span> main() {
    say(<span class="string"><span class="delimiter">&quot;</span><span class="content">world</span><span class="delimiter">&quot;</span></span>)
    say(<span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span>)
}
</pre></div>
</div>
 </figure></notextile></div>

<p>A very basic example that can demonstrate goroutines. Now, if we change <strong>one</strong> of the say functions inside main to a goroutine, this happens:</p>

<div><div class="CodeRay">
  <div class="code"><pre>root@debian:~/Software/Experiments/go# ./a.out
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</pre></div>
</div>
</div>

<p><strong>BUT</strong> if we change <strong>BOTH</strong> of these functions to goroutines (<code>go say("world")</code>, <code>go say("hello")</code>), this happens:</p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
root@debian:~/Software/Experiments/go# ./a.out
root@debian:~/Software/Experiments/go# 
</pre></div>
</div>
 </figure></notextile></div>

<p>Wait a minute. It can‚Äôt be! Did it execute correctly? Where is the output? </p>

<div class="bogus-wrapper"><notextile><figure class="code"> <div class="CodeRay">
  <div class="code"><pre>
root@debian:~/Software/Experiments/go# echo $?
0
root@debian:~/Software/Experiments/go#
</pre></div>
</div>
 </figure></notextile></div>

<p>It reports that it has executed correctly. But there is no output.</p>

<h2 id="what-i-am-doing-next">What I am doing next</h2>

<p>I will continue reading through the go runtime for some clues. On the more active size, I am writing a custom test case for goroutine testing under the Hurd, while also doing some analysis
on the programs that run there (currently studying the assembly generated for these programs) to see how they differ and why we get this particular behavior.</p>

  
  


    </article>
  

    <nav role="navigation" id="pagination">
  <span class="next">
    <a href="/blog/page/2/" rel="next">Continue &rarr;</a>
  </span>


</nav>
  </section>
  

  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




</body>
</html>
