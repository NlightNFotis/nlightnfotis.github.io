<!DOCTYPE html>
<html lang="en-GB">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Lambda reflections</title>
  <meta name="description" content="Functional Programming, Proofs, Bioinformatics and more.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://nlightnfotis.github.io/posts/4/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Lambda reflections" href="https://nlightnfotis.github.io/feed.xml">

  

  
  <meta property="og:title" content="Lambda reflections">
  <meta property="og:site_name" content="Lambda reflections">
  <meta property="og:url" content="https://nlightnfotis.github.io/posts/4/">
  <meta property="og:description" content="Functional Programming, Proofs, Bioinformatics and more.">
  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="NlightNFotis">
  <meta name="twitter:title" content="Lambda reflections">
  <meta name="twitter:description" content="Functional Programming, Proofs, Bioinformatics and more.">
  
    <meta name="twitter:creator" content="NlightNFotis">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Lambda reflections</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/NlightNFotis">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2013/08/12/gsoc-week-8-partial-report/">GSOC Week 8 (Partial) report</a>
            
          </h1>

          <p class="post-meta">
            Aug 12, 2013
            
              

 •
  
    
    
      
        <a href="/tags/gsoc/">gsoc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/tags/golang/">golang</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
        <a href="/tags/gcc/">gcc</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


            
            
          </p>
        </header>

        <div class="post-content">
          <p>This week was spent studying the go language’s runtime and studying the behaviour of various go programs when executed under the Hurd. I learnt a variety of new things, and got some 
new clues about the problem.</p>

<h2>The new libgo clues</h2>

<p>I already know that <em>M’s are the “real” kernel schedulable threads</em> and <em>G’s are the go runtime managed ones (goroutines)</em>. Last time I had gone through the go runtime’s code I had noticed that neither of them get created, so there must be an issue with thread creation. <strong>But since there is at least one of each created during the program’s initialization, how come
most programs are able to run, and issues present themselves when we manually attempt to run a goroutine?</strong></p>

<p>I will admit that the situation looks strange. So I decided to look more into it. Before we go any further, I have to embed the issues I had when I run goroutine powered programs under the Hurd.</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@debian:~/Software/Experiments/go# ./a.out
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">__pthread_create_internal</code> is a libpthread function that gets called when a new posix thread is instanciated. So we know that when we call a goroutine, apart from the goroutine,
there is at least one kernel thread created, otherwise, if a new goroutine was created, and not a new kernel thread (M) why wasn’t it matched with an existing kernel thread
(remember there is at least one).</p>

<p>That made me look into the go runtime some more. I found a lot of things, that I can not enumerate here, but amongst the most interesting ones, was the following piece of code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Create a new m.  It will start off with a call to runtime_mstart.</span>
<span class="n">M</span><span class="o">*</span>
<span class="nf">runtime_newm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">M</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
	<span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">stacksize</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">clear</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">old</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="c">#if 0
	static const Type *mtype;  // The Go type M
	if(mtype == nil) {
		Eface e;
		runtime_gc_m_ptr(&amp;e);
		mtype = ((const PtrType*)e.__type_descriptor)-&gt;__element_type;
	}
#endif
</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="n">runtime_mal</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mcommoninit</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mp</span><span class="o">-&gt;</span><span class="n">g0</span> <span class="o">=</span> <span class="n">runtime_malg</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nil</span><span class="p">,</span> <span class="n">nil</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">runtime_throw</span><span class="p">(</span><span class="s">"pthread_attr_init"</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_DETACHED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">runtime_throw</span><span class="p">(</span><span class="s">"pthread_attr_setdetachstate"</span><span class="p">);</span>

	<span class="n">stacksize</span> <span class="o">=</span> <span class="n">PTHREAD_STACK_MIN</span><span class="p">;</span>

	<span class="c1">// With glibc before version 2.16 the static TLS size is taken</span>
	<span class="c1">// out of the stack size, and we get an error or a crash if</span>
	<span class="c1">// there is not enough stack space left.  Add it back in if we</span>
	<span class="c1">// can, in case the program uses a lot of TLS space.  FIXME:</span>
	<span class="c1">// This can be disabled in glibc 2.16 and later, if the bug is</span>
	<span class="c1">// indeed fixed then.</span>
	<span class="n">stacksize</span> <span class="o">+=</span> <span class="n">tlssize</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">pthread_attr_setstacksize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">stacksize</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">runtime_throw</span><span class="p">(</span><span class="s">"pthread_attr_setstacksize"</span><span class="p">);</span>

	<span class="c1">// Block signals during pthread_create so that the new thread</span>
	<span class="c1">// starts with signals disabled.  It will enable them in minit.</span>
	<span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clear</span><span class="p">);</span>

<span class="cp">#ifdef SIGTRAP
</span>	<span class="c1">// Blocking SIGTRAP reportedly breaks gdb on Alpha GNU/Linux.</span>
	<span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clear</span><span class="p">,</span> <span class="n">SIGTRAP</span><span class="p">);</span>
<span class="cp">#endif
</span>
	<span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
	<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clear</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">runtime_mstart</span><span class="p">,</span> <span class="n">mp</span><span class="p">);</span>
	<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">,</span> <span class="n">nil</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">runtime_throw</span><span class="p">(</span><span class="s">"pthread_create"</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mp</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>This is the code that creates a new kernel thread. Notice the line <code class="language-plaintext highlighter-rouge">ret = pthread_create(&amp;tid, &amp;attr, runtime_mstart, mp);</code>. It’s obvious that it creates a new kernel thread,
so that explains why we get the specific error. But what is not explained is that since we do have at least one in program startup, why is this specific error only triggered when
we manually create a go routine?</p>

<h2>Go programs under the Hurd</h2>

<p>Apart from studying Go’s runtime source code, I also run some experiments under the Hurd. I got some very weird results that I am investigating, but I would like to share nonetheless.
Consider the following piece of code:</p>

<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">say</span><span class="p">(</span><span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">say</span><span class="p">(</span><span class="s">"world"</span><span class="p">)</span>
    <span class="n">say</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>A very basic example that can demonstrate goroutines. Now, if we change <strong>one</strong> of the say functions inside main to a goroutine, this happens:</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@debian:~/Software/Experiments/go# ./a.out
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</code></pre></div></div>

<p><strong>BUT</strong> if we change <strong>BOTH</strong> of these functions to goroutines (<code class="language-plaintext highlighter-rouge">go say("world")</code>, <code class="language-plaintext highlighter-rouge">go say("hello")</code>), this happens:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">root@debian:~/Software/Experiments/go# ./a.out
root@debian:~/Software/Experiments/go# </code></pre></figure>

<p>Wait a minute. It can’t be! Did it execute correctly? Where is the output?</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">root@debian:~/Software/Experiments/go# <span class="nb">echo</span> <span class="nv">$?</span>
0
root@debian:~/Software/Experiments/go#</code></pre></figure>

<p>It reports that it has executed correctly. But there is no output.</p>

<h2>What I am doing next</h2>

<p>I will continue reading through the go runtime for some clues. On the more active size, I am writing a custom test case for goroutine testing under the Hurd, while also doing some analysis
on the programs that run there (currently studying the assembly generated for these programs) to see how they differ and why we get this particular behavior.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2013/08/05/gsoc-partial-week-7-report/">GSOC (Partial) Week 7 report</a>
            
          </h1>

          <p class="post-meta">
            Aug 5, 2013
            
               •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/gsoc/">gsoc</a>,
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/golang/">golang</a>,
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/gcc/">gcc</a>
      
    
  




            
            
          </p>
        </header>

        <div class="post-content">
          <h1>An exciting week.</h1>

<p>This week was exciting. Spending it on learning about the go runtime was the reason for this. As insightfull as it was however,
it also confused me a little bit. Before this goes any further, I should state that this is a partial report on my research
and my findings. My aims for this week were the following: <strong>To investigate the behavior of go programs under the Hurd, to
study the go runtime, and possibly modify it to see if the goroutine issues are libpthread’s issue or the go’s runtime issue</strong>.</p>

<h1>Presenting my findings.</h1>

<p>Most of my time was spent studying the gcc go frontend, libgo and the go runtime. Fortunatelly, I can say (gladly) that it was
time well spent. What I got from it were some nice pieces of insight, but also some slight confusion and doubts.</p>

<p>The first interesting thing in my findings was this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span>	<span class="n">G</span>
<span class="p">{</span>
	<span class="n">Defer</span><span class="o">*</span>	<span class="n">defer</span><span class="p">;</span>
	<span class="n">Panic</span><span class="o">*</span>	<span class="n">panic</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span>	<span class="n">exception</span><span class="p">;</span>	<span class="c1">// current exception being thrown</span>
	<span class="n">bool</span>	<span class="n">is_foreign</span><span class="p">;</span>	<span class="c1">// whether current exception from other language</span>
	<span class="kt">void</span>	<span class="o">*</span><span class="n">gcstack</span><span class="p">;</span>	<span class="c1">// if status==Gsyscall, gcstack = stackbase to use during gc</span>
	<span class="n">uintptr</span>	<span class="n">gcstack_size</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span>	<span class="n">gcnext_segment</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span>	<span class="n">gcnext_sp</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span>	<span class="n">gcinitial_sp</span><span class="p">;</span>
	<span class="n">ucontext_t</span> <span class="n">gcregs</span><span class="p">;</span>
	<span class="n">byte</span><span class="o">*</span>	<span class="n">entry</span><span class="p">;</span>		<span class="c1">// initial function</span>
	<span class="n">G</span><span class="o">*</span>	<span class="n">alllink</span><span class="p">;</span>	<span class="c1">// on allg</span>
	<span class="kt">void</span><span class="o">*</span>	<span class="n">param</span><span class="p">;</span>		<span class="c1">// passed parameter on wakeup</span>
	<span class="n">bool</span>	<span class="n">fromgogo</span><span class="p">;</span>	<span class="c1">// reached from gogo</span>
	<span class="n">int16</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">int64</span>	<span class="n">goid</span><span class="p">;</span>
	<span class="n">uint32</span>	<span class="n">selgen</span><span class="p">;</span>		<span class="c1">// valid sudog pointer</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span>	<span class="n">waitreason</span><span class="p">;</span>	<span class="c1">// if status==Gwaiting</span>
	<span class="n">G</span><span class="o">*</span>	<span class="n">schedlink</span><span class="p">;</span>
	<span class="n">bool</span>	<span class="n">readyonstop</span><span class="p">;</span>
	<span class="n">bool</span>	<span class="n">ispanic</span><span class="p">;</span>
	<span class="n">bool</span>	<span class="n">issystem</span><span class="p">;</span>
	<span class="n">int8</span>	<span class="n">raceignore</span><span class="p">;</span> <span class="c1">// ignore race detection events</span>
	<span class="n">M</span><span class="o">*</span>	<span class="n">m</span><span class="p">;</span>		<span class="c1">// for debuggers, but offset not hard-coded</span>
	<span class="n">M</span><span class="o">*</span>	<span class="n">lockedm</span><span class="p">;</span>
	<span class="n">M</span><span class="o">*</span>	<span class="n">idlem</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">sig</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">writenbuf</span><span class="p">;</span>
	<span class="n">byte</span><span class="o">*</span>	<span class="n">writebuf</span><span class="p">;</span>
	<span class="c1">// DeferChunk	*dchunk;</span>
	<span class="c1">// DeferChunk	*dchunknext;</span>
	<span class="n">uintptr</span>	<span class="n">sigcode0</span><span class="p">;</span>
	<span class="n">uintptr</span>	<span class="n">sigcode1</span><span class="p">;</span>
	<span class="c1">// uintptr	sigpc;</span>
	<span class="n">uintptr</span>	<span class="n">gopc</span><span class="p">;</span>	<span class="c1">// pc of go statement that created this goroutine</span>

	<span class="n">int32</span>	<span class="n">ncgo</span><span class="p">;</span>
	<span class="n">CgoMal</span><span class="o">*</span>	<span class="n">cgomal</span><span class="p">;</span>

	<span class="n">Traceback</span><span class="o">*</span> <span class="n">traceback</span><span class="p">;</span>

	<span class="n">ucontext_t</span>	<span class="n">context</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span>		<span class="n">stack_context</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">};</span></code></pre></figure>

<p>Yep. This is the code that resembles a (yeah, you guessed it, a <strong>goroutine</strong>). I was pretty surprised at first to see that a thread is resembled as a struct. But then again,
taking a closer look at it, it makes perfect sense. The next one though was a <em>lot trickier</em>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span>	<span class="n">M</span>
<span class="p">{</span>
	<span class="n">G</span><span class="o">*</span>	<span class="n">g0</span><span class="p">;</span>		<span class="c1">// goroutine with scheduling stack</span>
	<span class="n">G</span><span class="o">*</span>	<span class="n">gsignal</span><span class="p">;</span>	<span class="c1">// signal-handling G</span>
	<span class="n">G</span><span class="o">*</span>	<span class="n">curg</span><span class="p">;</span>		<span class="c1">// current running goroutine</span>
	<span class="n">int32</span>	<span class="n">id</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">mallocing</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">throwing</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">gcing</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">locks</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">nomemprof</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">waitnextg</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">dying</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">profilehz</span><span class="p">;</span>
	<span class="n">int32</span>	<span class="n">helpgc</span><span class="p">;</span>
	<span class="n">uint32</span>	<span class="n">fastrand</span><span class="p">;</span>
	<span class="n">uint64</span>	<span class="n">ncgocall</span><span class="p">;</span>	<span class="c1">// number of cgo calls in total</span>
	<span class="n">Note</span>	<span class="n">havenextg</span><span class="p">;</span>
	<span class="n">G</span><span class="o">*</span>	<span class="n">nextg</span><span class="p">;</span>
	<span class="n">M</span><span class="o">*</span>	<span class="n">alllink</span><span class="p">;</span>	<span class="c1">// on allm</span>
	<span class="n">M</span><span class="o">*</span>	<span class="n">schedlink</span><span class="p">;</span>
	<span class="n">MCache</span>	<span class="o">*</span><span class="n">mcache</span><span class="p">;</span>
	<span class="n">G</span><span class="o">*</span>	<span class="n">lockedg</span><span class="p">;</span>
	<span class="n">G</span><span class="o">*</span>	<span class="n">idleg</span><span class="p">;</span>
	<span class="n">Location</span> <span class="n">createstack</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="c1">// Stack that created this thread.</span>
	<span class="n">M</span><span class="o">*</span>	<span class="n">nextwaitm</span><span class="p">;</span>	<span class="c1">// next M waiting for lock</span>
	<span class="n">uintptr</span>	<span class="n">waitsema</span><span class="p">;</span>	<span class="c1">// semaphore for parking on locks</span>
	<span class="n">uint32</span>	<span class="n">waitsemacount</span><span class="p">;</span>
	<span class="n">uint32</span>	<span class="n">waitsemalock</span><span class="p">;</span>
	<span class="n">GCStats</span>	<span class="n">gcstats</span><span class="p">;</span>
	<span class="n">bool</span>	<span class="n">racecall</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span>	<span class="n">racepc</span><span class="p">;</span>

	<span class="n">uintptr</span>	<span class="n">settype_buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
	<span class="n">uintptr</span>	<span class="n">settype_bufsize</span><span class="p">;</span>

	<span class="n">uintptr</span>	<span class="n">end</span><span class="p">[];</span>
<span class="p">};</span></code></pre></figure>

<p>This was a source of endless confusion at the beginning. It does have some hints reassuring the fact that G’s are indeed goroutines, but nothing that really helps to describe what an M is.
It’s structure is identical to that of the G however, which means that it might have something to do with a thread. And indeed it is. Further study of the source code
made me speculate that <strong>M’s must be the real operating system scheduled (kernel) threads, while G’s (goroutines) must be the lightweight threads managed by the go runtime.</strong></p>

<p>I was more than happy to find comments that reassured that position of mine.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The go scheduler's job is to match ready-to-run goroutines (`g's)
// with waiting-for-work schedulers (`m's)
</code></pre></div></div>

<p>Another cool finding was the go (runtime) scheduler - from which the above comment originates:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">Sched</span> <span class="p">{</span>
	<span class="n">Lock</span><span class="p">;</span>

	<span class="n">G</span> <span class="o">*</span><span class="n">gfree</span><span class="p">;</span>	<span class="c1">// available g's (status == Gdead)</span>
	<span class="n">int64</span> <span class="n">goidgen</span><span class="p">;</span>

	<span class="n">G</span> <span class="o">*</span><span class="n">ghead</span><span class="p">;</span>	<span class="c1">// g's waiting to run</span>
	<span class="n">G</span> <span class="o">*</span><span class="n">gtail</span><span class="p">;</span>
	<span class="n">int32</span> <span class="n">gwait</span><span class="p">;</span>	<span class="c1">// number of g's waiting to run</span>
	<span class="n">int32</span> <span class="n">gcount</span><span class="p">;</span>	<span class="c1">// number of g's that are alive</span>
	<span class="n">int32</span> <span class="n">grunning</span><span class="p">;</span>	<span class="c1">// number of g's running on cpu or in syscall</span>

	<span class="n">M</span> <span class="o">*</span><span class="n">mhead</span><span class="p">;</span>	<span class="c1">// m's waiting for work</span>
	<span class="n">int32</span> <span class="n">mwait</span><span class="p">;</span>	<span class="c1">// number of m's waiting for work</span>
	<span class="n">int32</span> <span class="n">mcount</span><span class="p">;</span>	<span class="c1">// number of m's that have been created</span>

	<span class="k">volatile</span> <span class="n">uint32</span> <span class="n">atomic</span><span class="p">;</span>	<span class="c1">// atomic scheduling word (see below)</span>

	<span class="n">int32</span> <span class="n">profilehz</span><span class="p">;</span>	<span class="c1">// cpu profiling rate</span>

	<span class="n">bool</span> <span class="n">init</span><span class="p">;</span>  <span class="c1">// running initialization</span>
	<span class="n">bool</span> <span class="n">lockmain</span><span class="p">;</span>  <span class="c1">// init called runtime.LockOSThread</span>

	<span class="n">Note</span>	<span class="n">stopped</span><span class="p">;</span>	<span class="c1">// one g can set waitstop and wait here for m's to stop</span>
<span class="p">};</span></code></pre></figure>

<p>From that particular piece of code, without a doubt the most interesting line is: <code class="language-plaintext highlighter-rouge">G *gfree</code>. That is a pool of the go routines that are available to be used.
There are also helper schedulling functions, from which, the most interesting (for my purposes), was the <code class="language-plaintext highlighter-rouge">static void gfput(G*);</code> which realeases a go routine (puts it to the gfree list)</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Put on gfree list.  Sched must be locked.</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">gfput</span><span class="p">(</span><span class="n">G</span> <span class="o">*</span><span class="n">gp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">gp</span><span class="o">-&gt;</span><span class="n">schedlink</span> <span class="o">=</span> <span class="n">runtime_sched</span><span class="p">.</span><span class="n">gfree</span><span class="p">;</span>
	<span class="n">runtime_sched</span><span class="p">.</span><span class="n">gfree</span> <span class="o">=</span> <span class="n">gp</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>There are loads of other extremely interesting functions there, but for the sake of space I will not expand here more. However I will expand on what it is that is confusing me:</p>

<h2>The source of confusion</h2>

<p>My tests in this point are to include testing if removing thread destruction from the go runtime would result in difference in behavior.
There are however (as far as go is concerned), two kinds of threads in the go runtime. <strong>Goroutines</strong> (G’s) and the <strong>kernel schedulable threads</strong> (M’s).</p>

<p>Neither of which, seem to really be destroyed. From my understanding so far, G’s are never totally destroyed (I may be wrong here, I am still researching this bit). Whenever
they are about to “destroyed”, they are added to the scheduler’s list of freeG’s to allow for reuse, as evidenced by the <code class="language-plaintext highlighter-rouge">gfput</code> and <code class="language-plaintext highlighter-rouge">gfget</code> functions. 
M’s on the other hand (the kernel threads), also seem to not be destroyed. A comment in go’s scheduler seems to support this (<code class="language-plaintext highlighter-rouge">// For now, m's never go away.</code>) and as a 
matter of fact I could not find any code that destroyed M’s (I am still researching this bit).</p>

<p><strong>Since none of the two actually get destroyed, and seeing as thread creation alone should not be buggy, how come we are facing the specific bugs we are facing?</strong>
I will try to provide with an interpretation: Either I am fairly wrong and M’s (or G’s or both) actually do get destroyed somewhere (possible and very much probable)
or I looking for clues regarding the issue in the wrong place (might be possible but I don’t see it being very probable).</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2013/07/31/gsoc-week-6-report/">GSOC: Week 6 report</a>
            
          </h1>

          <p class="post-meta">
            Jul 31, 2013
            
              

 •
  
    
    
      
        <a href="/tags/gsoc/">gsoc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
        <a href="/tags/gcc/">gcc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/tags/golang/">golang</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


            
            
          </p>
        </header>

        <div class="post-content">
          <p>First of all, I would like to apologize for this report being late. But unfortunately this happened:
<img src="http://i1.kym-cdn.com/photos/images/original/000/000/376/Accidentally93mb20110724-22047-ix1t06.png" alt="I Accidentally 93 MB" /></p>

<p>Only that, in my case, it was not exactly 93 MB, rather it was about 1.5GB. Yeah, <em>I accidentally obliterated my <strong>GCC</strong> repository on the Hurd</em>, so I had to reclone and rebuild everything, something that took considerable amounts of time. 
How this happened is a long story that involved me wanting to rebuild my gcc, and <code class="language-plaintext highlighter-rouge">cd</code>-ing 2 directories above the build folder, and ending up <code class="language-plaintext highlighter-rouge">rm -rf *</code> from my <code class="language-plaintext highlighter-rouge">gcc</code> folder (that included the source, and the build folder) rather than my <code class="language-plaintext highlighter-rouge">gcc_build</code> folder. 
Thank god, that was only a minor setback, and the (small scale) crisis was soon averted.</p>

<h1>Further research</h1>

<p>This week was mostly spent reading source code, primarily looking for clues for the previous situation, and secondarily to get a better undestanding of the systems I am working on. This proved to be fertile, as I got a firmer grip of libpthread, and the GNU Mach system. However, while this week was mostly spent reading documentation, that doesn’t mean that I didn’t do anything practical. I also used my time to do some further research into what was it specifically that triggered the assertion failure. That required us to play a little bit with our newly built compiler on the Hurd and see what we can do with go on the Hurd.</p>

<h2>Testing gccgo under the Hurd</h2>

<p>If you recall correctly, the last time I reported I had found out that an assertion on <code class="language-plaintext highlighter-rouge">libpthread</code>`s code was failing, and that was the root cause that failed both the <code class="language-plaintext highlighter-rouge">gccgo</code> tests
and the <code class="language-plaintext highlighter-rouge">libgo</code> tests. That assertion was failing at two different places in the code, the first being <code class="language-plaintext highlighter-rouge">__pthread_create_internal</code> which is a <code class="language-plaintext highlighter-rouge">libpthread</code> function 
located in <code class="language-plaintext highlighter-rouge">libpthread/pthread/pt-create.c</code> and is invoked when an application wants to create a new POSIX thread. That function of course is not getting called directly, rather
it is invoked by <code class="language-plaintext highlighter-rouge">pthread_create</code> which is the function that user space application use to create the new thread. (For reference reasons you can find the code <a href="https://github.com/NlightNFotis/libpthread/blob/master/pthread/pt-create.c#L67">here</a>)</p>

<p>The second place where that assertion was failing was at <code class="language-plaintext highlighter-rouge">__sem_timedwait_internal</code> at the file <a href="https://github.com/NlightNFotis/libpthread/blob/master/sysdeps/generic/sem-timedwait.c">libpthread/sysdeps/generic/sem-timedwait.c</a>, where it gets inlined in the place of <code class="language-plaintext highlighter-rouge">self = _pthread_self ();</code>. (For more information, checkout last week’s report).</p>

<p>So I was curious to test out the execution of some sample programs under the compiler we built on the Hurd. <strong>Beginning with some very simple hello world like programs, we could see that
they were compiling successfully, and also ran successfully without any issues at all.</strong> Seeing as the assertion failure is generated when we attempt to create a new thread, I figured I might want to start playing with go routines under the Hurd.</p>

<p>So we started playing with a simple hello world like goroutine example (the one available under the <a href="http://tour.golang.org/#62">tour of go on the golang.org website.</a>)</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">package</span> <span class="n">main</span>

<span class="nf">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>
<span class="p">)</span>

<span class="n">func</span> <span class="n">say</span><span class="p">(</span><span class="n">s</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">time</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
        <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">say</span><span class="p">(</span><span class="s">"world"</span><span class="p">)</span>
    <span class="n">say</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>This gets compiled without any issues at all, but when we try to run it…</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">pthread</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">sysdeps</span><span class="o">/</span><span class="n">generic</span><span class="o">/</span><span class="n">sem</span><span class="o">-</span><span class="n">timedwait</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">50</span><span class="o">:</span> <span class="n">__sem_timedwait_internal</span><span class="o">:</span> <span class="n">Assertion</span> <span class="err">`</span><span class="p">({</span> <span class="n">mach_port_t</span> <span class="n">ktid</span> <span class="o">=</span> <span class="n">__mach_thread_self</span> <span class="p">();</span> <span class="kt">int</span> <span class="n">ok</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">kernel_thread</span> <span class="o">==</span> <span class="n">ktid</span><span class="p">;</span> <span class="n">__mach_port_deallocate</span> <span class="p">((</span><span class="n">__mach_task_self_</span> <span class="o">+</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ktid</span><span class="p">);</span> <span class="n">ok</span><span class="p">;</span> <span class="p">})</span><span class="err">'</span> <span class="n">failed</span><span class="p">.</span>
<span class="n">Aborted</span>


<span class="n">goroutine</span> <span class="mi">1</span> <span class="p">[</span><span class="n">sleep</span><span class="p">]</span><span class="o">:</span>
<span class="n">time</span><span class="p">.</span><span class="n">Sleep</span>
	<span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">gcc_source</span><span class="o">/</span><span class="n">libgo</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">time</span><span class="p">.</span><span class="n">goc</span><span class="o">:</span><span class="mi">26</span>

<span class="n">goroutine</span> <span class="mi">3</span> <span class="p">[</span><span class="n">sleep</span><span class="p">]</span><span class="o">:</span>
<span class="n">time</span><span class="p">.</span><span class="n">Sleep</span>
	<span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="p">..</span><span class="o">/</span><span class="n">gcc_source</span><span class="o">/</span><span class="n">libgo</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">time</span><span class="p">.</span><span class="n">goc</span><span class="o">:</span><span class="mi">26</span></code></pre></figure>

<p>Bam! It exploded right infront of our face. Let’s see if this might become friendlier if we alter it a little bit. To do this we removed the <code class="language-plaintext highlighter-rouge">go</code> from <code class="language-plaintext highlighter-rouge">say</code> to avoid running it as a goroutine, and we also removed <code class="language-plaintext highlighter-rouge">time.Sleep</code> (along with the <code class="language-plaintext highlighter-rouge">time</code> import), <a href="https://github.com/NlightNFotis/gcc/blob/master/libgo/go/time/sleep.go#L8">whose job is to pause a go routine</a>.</p>

<p>When you do this, the code seems to be a hello world like for loop sample, that prints:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@debian:~/Software/Experiments/go# ./a.out
world
world
world
world
world
hello
hello
hello
hello
hello
</code></pre></div></div>

<p>Hmm. Let’s play with it some more. Changing our code a little bit to make <code class="language-plaintext highlighter-rouge">say("world")</code> run as a goroutine gives us the following code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">package</span> <span class="n">main</span>

<span class="n">import</span> <span class="s">"fmt"</span>

<span class="n">func</span> <span class="nf">say</span><span class="p">(</span><span class="n">s</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">say</span><span class="p">(</span><span class="s">"world"</span><span class="p">)</span>
    <span class="n">say</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Which, when executed results in this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@debian:~/Software/Experiments/go# ./a.out
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</code></pre></div></div>

<p>So we can see that the simplest go programs that run with goroutines do not run. Let’s still try some programs that invoke goroutines to see if our assumptions are correct.
Below is the code of a very simple web server in go (<a href="http://tour.golang.org/#56">found in the golang website</a>).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">package</span> <span class="n">main</span>

<span class="nf">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"net/http"</span>
<span class="p">)</span>

<span class="n">type</span> <span class="n">Hello</span> <span class="k">struct</span><span class="p">{}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">h</span> <span class="n">Hello</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span>
    <span class="n">w</span> <span class="n">http</span><span class="p">.</span><span class="n">ResponseWriter</span><span class="p">,</span>
    <span class="n">r</span> <span class="o">*</span><span class="n">http</span><span class="p">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s">"Hello!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">h</span> <span class="n">Hello</span>
    <span class="n">http</span><span class="p">.</span><span class="n">ListenAndServe</span><span class="p">(</span><span class="s">"localhost:4000"</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>The (non surprising) result is the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
Aborted

goroutine 1 [syscall]:
no stack trace available
</code></pre></div></div>

<p>Hmm. This failure was last caused by <code class="language-plaintext highlighter-rouge">time.Sleep</code>. So let’s take a closer look into the code of the <code class="language-plaintext highlighter-rouge">ListenAndServe</code> function. The code for this function in the go runtime is this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// ListenAndServe listens on the TCP network address srv.Addr and then</span>
<span class="c1">// calls Serve to handle requests on incoming connections.  If</span>
<span class="c1">// srv.Addr is blank, ":http" is used.</span>
<span class="n">func</span> <span class="p">(</span><span class="n">srv</span> <span class="o">*</span><span class="n">Server</span><span class="p">)</span> <span class="n">ListenAndServe</span><span class="p">()</span> <span class="n">error</span> <span class="p">{</span>
	<span class="n">addr</span> <span class="o">:=</span> <span class="n">srv</span><span class="p">.</span><span class="n">Addr</span>
	<span class="k">if</span> <span class="n">addr</span> <span class="o">==</span> <span class="s">""</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="s">":http"</span>
	<span class="p">}</span>
	<span class="n">l</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">net</span><span class="p">.</span><span class="n">Listen</span><span class="p">(</span><span class="s">"tcp"</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">e</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">srv</span><span class="p">.</span><span class="n">Serve</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>This calls the function <a href="https://github.com/NlightNFotis/gcc/blob/master/libgo/go/net/http/server.go#L1255"><code class="language-plaintext highlighter-rouge">Serve</code></a>. The interesting part in this one is line 1271:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
 time.Sleep(tempDelay)

</code></pre></div></div>

<p>It calls <code class="language-plaintext highlighter-rouge">time.Sleep</code> on accept failure. Which is known to pause go routines, and as a result be the ultimate cause for the result we are seeing.</p>

<h1>Final thoughts - Work for next week</h1>

<p>So pretty much everything that has anything to do with a goroutine is failing. Richard Braun on the #hurd suggested that since <strong>creation and destruction</strong> of threads is buggy in libpthread, maybe we should try a work around until a proper fix is in place. 
Apart from that my mentor Thomas Schwinge suggested to make thread destruction in go’s runtime a no-op to see if that makes any difference. 
If it does that should mean that there is nothing wrong in the go runtime itself, rather, the offending code is in libpthread. This is also my very next course of action, which I shall report on very soon.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2013/07/24/gsoc-week-5-report/">GSOC: Week 5 report</a>
            
          </h1>

          <p class="post-meta">
            Jul 24, 2013
            
              

 •
  
    
    
      
        <a href="/tags/gsoc/">gsoc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
        <a href="/tags/gcc/">gcc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/tags/golang/">golang</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


            
            
          </p>
        </header>

        <div class="post-content">
          <h1>A clue!</h1>

<p><strong>So last week we were left with the compiler test logs and the build results logs that we had to go through to checkout what was the root cause of all these failures in the gccgo test results, and more importantly in the libgo tests.</strong> So I went through the gccgo logs in search for a clue about why this may have happened. Here is the list of all the failures I compiled from the logs:</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
spawn [open ...]^M
doubleselect.x: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_s      elf_ + 0), ktid); ok; })' failed.
FAIL: go.test/test/chan/doubleselect.go execution,  -O2 -g

==========================================================

spawn [open ...]^M
nonblock.x: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_       + 0), ktid); ok; })' failed.
FAIL: go.test/test/chan/nonblock.go execution,  -O2 -g

==========================================================

Executing on host: /root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo -B/root/gcc_new/gccbuild/gcc/testsuite/go/../../  -fno-diagnostics-show-caret -fdiagnostics-color=never  -I/root/gcc_new/gccbuild/i68      6-unknown-gnu0.3/./libgo  -fsplit-stack -c  -o split_stack376.o split_stack376.c    (timeout = 300)
spawn /root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo -B/root/gcc_new/gccbuild/gcc/testsuite/go/../../ -fno-diagnostics-show-caret -fdiagnostics-color=never -I/root/gcc_new/gccbuild/i686-unknown-gnu0.      3/./libgo -fsplit-stack -c -o split_stack376.o split_stack376.c^M
cc1: error: '-fsplit-stack' currently only supported on GNU/Linux^M
cc1: error: '-fsplit-stack' is not supported by this compiler configuration^M
compiler exited with status 1
output is:
 cc1: error: '-fsplit-stack' currently only supported on GNU/Linux^M
 cc1: error: '-fsplit-stack' is not supported by this compiler configuration^M 

UNTESTED: go.test/test/chan/select2.go

==========================================================

Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open ...]^M
select3.x: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate       ((__mach_task_self_ + 0), ktid); ok; })' failed.
Aborted
 
FAIL: go.test/test/chan/select3.go execution,  -O2 -g

==========================================================

Executing on host: /root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo -B/root/gcc_new/gccbuild/gcc/testsuite/go/../../ /root/gcc_new/gcc/gcc/testsuite/go.test/test/chan/select5.go  -fno-diagnostics-show-      caret -fdiagnostics-color=never  -I/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo  -O  -w  -pedantic-errors  -L/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo -L/root/gcc_new/gccbuild/i686-unknown-      gnu0.3/./libgo/.libs  -lm   -o select5.exe    (timeout = 300)
spawn /root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo -B/root/gcc_new/gccbuild/gcc/testsuite/go/../../ /root/gcc_new/gcc/gcc/testsuite/go.test/test/chan/select5.go -fno-diagnostics-show-caret -fdiagno      stics-color=never -I/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo -O -w -pedantic-errors -L/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo -L/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.lib      s -lm -o select5.exe^M
PASS: go.test/test/chan/select5.go -O (test for excess errors)
FAIL: go.test/test/chan/select5.go execution

==========================================================

Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open ...]^M
bug147.x: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate       ((__mach_task_self_ + 0), ktid); ok; })' failed.
Aborted
 
FAIL: go.test/test/fixedbugs/bug147.go execution,  -O2 -g

=========================================================

Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open ...]^M
BUG: bug347: cannot find caller
Aborted
 
 
FAIL: go.test/test/fixedbugs/bug347.go execution,  -O0 -g

========================================================

Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open ...]^M
BUG: bug348: cannot find caller
panic: runtime error: invalid memory address or nil pointer dereference
[signal 0xb code=0x2 addr=0x0]
 
goroutine 1 [running]:
FAIL: go.test/test/fixedbugs/bug348.go execution,  -O0 -g

========================================================

Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open ...]^M
mallocfin.x: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self      _ + 0), ktid); ok; })' failed.
FAIL: go.test/test/mallocfin.go execution,  -O2 -g

=======================================================

Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open ...]^M
Aborted
 
 
FAIL: go.test/test/nil.go execution,  -O2 -g

======================================================

Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open ...]^M
Aborted
 
 
FAIL: go.test/test/recover3.go execution,  -O2 -g

</code></pre></div></div>

<p><em>See a pattern there?</em> Well certainly I do. In several occasions, the root cause for the fail is this:</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate       ((__mach_task_self_ + 0), ktid); ok; })' failed.
</code></pre></div></div>

<p>Hmm… That’s interesting. Let us go through the libgo results too.</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Test Run By root on Fri Jul 12 17:56:44 UTC 2013
Native configuration is i686-unknown-gnu0.3

		=== libgo tests ===

a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 10005 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: bufio
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (10005) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 10637 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: bytes
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (10637) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 10757 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: errors
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (10757) - No such process
a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
Aborted


goroutine 1 [syscall]:
no stack trace available
FAIL: expvar
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (10886) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11058 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: flag
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11058) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11475 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: fmt
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11475) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11584 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: html
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11584) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11747 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: image
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11747) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11999 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: io
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11999) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 12116 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: log
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (12116) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 13107 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: math
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (13107) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 13271 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: mime
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (13271) - No such process
a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
Aborted


goroutine 1 [chan receive]:
a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
panic during panic
testing.RunTestsFAIL: net
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (14234) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 14699 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: os
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (14699) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 14860 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: path
timed out in gotest

...


runtest completed at Fri Jul 12 18:09:07 UTC 2013
</code></pre></div></div>

<p>That’s certainly even more interesting. In case you haven’t noticed, it’s the same assertion that caused the failures in gccgo test suite. Let us find the offending code, shall we?</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* Set the new thread's signal mask and set the pending signals to
     empty.  POSIX says: "The signal mask shall be inherited from the
     creating thread.  The set of signals pending for the new thread
     shall be empty."  If the currnet thread is not a pthread then we
     just inherit the process' sigmask.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__pthread_num_threads</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">sigprocmask</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigset</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">__pthread_sigstate</span> <span class="p">(</span><span class="n">_pthread_self</span> <span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">assert_perror</span> <span class="p">(</span><span class="n">err</span><span class="p">);</span></code></pre></figure>

<p>This seems to be the code that the logs point to. But no sign of the assertion. After discussing this issue with my peers in #hurd, I was told that the code I was looking for (the failing assertion), is getting inlined via <code class="language-plaintext highlighter-rouge">_pthread_self ()</code> and is actually located in <code class="language-plaintext highlighter-rouge">libpthread/sysdeps/mach/hurd/pt-sysdep.h</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">extern</span> <span class="kr">__thread</span> <span class="k">struct</span> <span class="n">__pthread</span> <span class="o">*</span><span class="n">___pthread_self</span><span class="p">;</span>
<span class="cp">#define _pthread_self()                                            \
	({                                                         \
	  struct __pthread *thread;                                \
	                                                           \
	  assert (__pthread_threads);                              \
	  thread = ___pthread_self;                                \
	                                                           \
	  assert (thread);                                         \
	  assert (({ mach_port_t ktid = __mach_thread_self ();     \
                     int ok = thread-&gt;kernel_thread == ktid;       \
                     __mach_port_deallocate (__mach_task_self (), ktid);\
                     ok; }));                                      \
          thread;                                                  \
         })</span></code></pre></figure>

<p>So this is what I was looking for. Further discussing it in the weekly IRC meeting, braunr provided me with some more clues:</p>

<blockquote>
  <p>08:38:15 braunr&gt; nlightnfotis: did i answer that ?<br />
08:38:24 nlightnfotis&gt; braunr: which one?<br />
08:38:30 nlightnfotis&gt; hello btw :)<br />
08:38:33 braunr&gt; the problems you’re seeing are the pthread resources leaks i’ve been trying to fix lately<br />
08:38:58 braunr&gt; they’re not only leaks<br />
08:39:08 braunr&gt; creation and destruction are buggy <br />
08:39:37 nlightnfotis&gt; I have read so in http://www.gnu.org/software/hurd/libpthread.html. I believe it’s under Thread’s Death right?<br />
08:40:15 braunr&gt; nlightnfotis: yes but it’s buggy<br />
08:40:22 braunr&gt; and the description doesn’t describe the bugs<br />
08:41:02 nlightnfotis&gt; so we will either have to find a temporary workaround, or better yet work on a fix, right?<br />
08:41:12 braunr&gt; nlightnfotis: i also told you the work around<br />
08:41:16 braunr&gt; nlightnfotis: create a thread pool</p>
</blockquote>

<h1>Work for next week</h1>

<p>This leaves us with next week’s work, which is to hack in libpthread’s code to attempt to create a thread pool, so that we avoid some of the issues that are present now with the current implementation of the Hurd libpthread code.</p>

<p>It was also suggested by Samuel Thibault (youpi) that I should run the libgo tests by hand and see if I get some more clues, like stack traces. It sounds like a good idea to me, so that’s something that I will look into too.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            
              <a class="post-link" href="/2013/07/15/gsoc-week-4-report/">GSOC: Week 4 report</a>
            
          </h1>

          <p class="post-meta">
            Jul 15, 2013
            
              

 •
  
    
    
      
        <a href="/tags/gsoc/">gsoc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
        <a href="/tags/gcc/">gcc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/tags/golang/">golang</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


            
            
          </p>
        </header>

        <div class="post-content">
          <h1>Yeah baby! It builds!</h1>

<p><strong>The highlight of this week’s progress was managing to successfully build
gccgo under the Hurd.</strong>
Not only did it compile successfully, it also run its tests, with the
results <a href="http://lists.gnu.org/archive/html/bug-hurd/2013-06/msg00117.html">matching the ones provided by my mentor Thomas Schwinge</a>.
This was a checkpoint in my summer of code project. Successful building of
the compiler meant that I am (happily) in the position to carry on with the
next part (and the main one) of my project, that is, to make sure that
the <strong>go library (libgo) also passes all its tests 
and works without any major issues.</strong></p>

<h1>So where are we now?</h1>

<h2>gccgo</h2>

<p>Compiling gccgo on the Hurd was big. But we also had to see how it 
compared to the build that was successful on Linux. The most effective
way to compare the two builds, is to check the test results of the two.</p>

<p>Taking a look at the gccgo results on the Hurd, I was delighted to find 
that it passed most of its tests. There were few that were failing, but 
for the most part, it did well. Below are the test results of gccgo on the Hurd:</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     === go Summary ===

# of expected passes        5069
# of unexpected failures    11
# of expected failures      1
# of untested testcases     6
/root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo  version 4.9.0 20130606 (experimental) (GCC)

</code></pre></div></div>

<p>So it’s passing 99% of its tests. That’s cool. But it could help to take a look
at the tests that are failing, to get an idea of what the fails are, how critical they are, etc</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nlightnfotis@earth:~/HurdVM/HurdFiles$ grep -v ^PASS: &lt; go.sum
Test Run By root on Thu Jul 11 10:33:34 2013
Native configuration is i686-unknown-gnu0.3

        === go tests ===

        Schedule of variations:
            unix

            Running target unix
            Running /root/gcc_new/gcc/gcc/testsuite/go.dg/dg.exp ...
            Running /root/gcc_new/gcc/gcc/testsuite/go.go-torture/execute/execute.exp ...
            Running /root/gcc_new/gcc/gcc/testsuite/go.test/go-test.exp ...
            FAIL: go.test/test/chan/doubleselect.go execution,  -O2 -g 
            FAIL: go.test/test/chan/nonblock.go execution,  -O2 -g 
            UNTESTED: go.test/test/chan/select2.go
            FAIL: go.test/test/chan/select3.go execution,  -O2 -g 
            FAIL: go.test/test/chan/select5.go execution
            UNTESTED: go.test/test/closure.go
            FAIL: go.test/test/fixedbugs/bug147.go execution,  -O2 -g 
            FAIL: go.test/test/fixedbugs/bug347.go execution,  -O0 -g 
            FAIL: go.test/test/fixedbugs/bug348.go execution,  -O0 -g 
            XFAIL: bug429.go  -O2 -g  execution test
            FAIL: go.test/test/goprint.go execution
            UNTESTED: go.test/test/goprint.go compare
            UNTESTED: go.test/test/init1.go
            FAIL: go.test/test/mallocfin.go execution,  -O2 -g 
            FAIL: go.test/test/nil.go execution,  -O2 -g 
            FAIL: go.test/test/recover3.go execution,  -O2 -g 
            UNTESTED: go.test/test/rotate.go
            UNTESTED: go.test/test/stack.go

                    === go Summary ===

# of expected passes        5069
# of unexpected failures    11
# of expected failures      1
# of untested testcases     6
/root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo  version 4.9.0 20130606 (experimental) (GCC) 
</code></pre></div></div>

<p>Hmm. So these are the failing tests. Before we go through them, it might be a good idea
to check the status of the gccgo tests on the Linux build too. Let’s see.</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nlightnfotis@earth:~$ grep -v ^PASS: &lt; linux_go.sum 
Test Run By fotis on Mon Jul 15 10:28:38 2013
Native configuration is i686-pc-linux-gnu

        === go tests ===

        Schedule of variations:
            unix

            Running target unix
            Running /home/fotis/Software/gcc/gcc/testsuite/go.dg/dg.exp ...
            Running /home/fotis/Software/gcc/gcc/testsuite/go.go-torture/execute/execute.exp ...
            Running /home/fotis/Software/gcc/gcc/testsuite/go.test/go-test.exp ...
            UNTESTED: go.test/test/closure.go
            XFAIL: bug429.go  -O2 -g  execution test
            UNTESTED: go.test/test/init1.go
            UNTESTED: go.test/test/rotate.go

                    === go Summary ===

# of expected passes        5183
# of expected failures      1
# of untested testcases     3
/home/fotis/Software/gcc_build/gcc/testsuite/go/../../gccgo  version 4.9.0 20130702 (experimental) (GCC) 
</code></pre></div></div>

<p>So, it seems like there are less tests failing here. But wait a minute. Those tests that are failing.
They are the same as with the Hurd build. So I can assume that we are left with 4 less tests to check
regarding their failures (Go on Linux works without any issues,so I guess it would be safe to skip those tests at the moment).
That leaves us with these tests to check:</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FAIL: go.test/test/chan/doubleselect.go execution,  -O2 -g
FAIL: go.test/test/chan/nonblock.go execution,  -O2 -g
UNTESTED: go.test/test/chan/select2.go
FAIL: go.test/test/chan/select3.go execution,  -O2 -g
FAIL: go.test/test/chan/select5.go execution
FAIL: go.test/test/fixedbugs/bug147.go execution,  -O2 -g
FAIL: go.test/test/fixedbugs/bug347.go execution,  -O0 -g
FAIL: go.test/test/fixedbugs/bug348.go execution,  -O0 -g
FAIL: go.test/test/goprint.go execution
UNTESTED: go.test/test/goprint.go compare
FAIL: go.test/test/mallocfin.go execution,  -O2 -g
FAIL: go.test/test/nil.go execution,  -O2 -g
FAIL: go.test/test/recover3.go execution,  -O2 -g
UNTESTED: go.test/test/stack.go
</code></pre></div></div>

<p>Discussing this with my mentor <a href="https://plus.google.com/101468009864620818344">Thomas Schwinge</a> in IRC (#hurd)</p>

<blockquote>
  <tschwinge> For now, please ignore any failing tests that have »select« in their name -- that is, do file them, but do not spend a lot of time figuring out what might be wrong there.
<tschwinge> The Hurd's select implementation is a bit of a beast, and I don't want you -- at this time -- spend a lot of time on that.  We already know there are some deficiencies, so we should postpone that to later.
</tschwinge></tschwinge>
</blockquote>

<p>So that leaves us with even less tests to check:</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FAIL: go.test/test/chan/nonblock.go execution,  -O2 -g
FAIL: go.test/test/fixedbugs/bug147.go execution,  -O2 -g
FAIL: go.test/test/fixedbugs/bug347.go execution,  -O0 -g
FAIL: go.test/test/fixedbugs/bug348.go execution,  -O0 -g
FAIL: go.test/test/goprint.go execution
UNTESTED: go.test/test/goprint.go compare
FAIL: go.test/test/mallocfin.go execution,  -O2 -g
FAIL: go.test/test/nil.go execution,  -O2 -g
FAIL: go.test/test/recover3.go execution,  -O2 -g
UNTESTED: go.test/test/stack.go
</code></pre></div></div>

<p>Nice. <strong>This narrowed down the list of errors that I have to go through to make sure that gccgo
works as well on the Hurd as it does on Linux.</strong></p>

<h2>libgo</h2>

<p>So, we talked about gccgo, but what about the runtime libraries (libgo)? They are also getting 
tested when we run <code class="language-plaintext highlighter-rouge">make check-go</code>and seeing as they are a vital part 
of enabling programs written on go to run on the Hurd, we ought
to take a look. (This was also the original goal of my project proposal).</p>

<p>So let us see what we have at the libgo.sum:</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Test Run By root on Fri Jul 12 17:56:44 UTC 2013
Native configuration is i686-unknown-gnu0.3

        === libgo tests ===

        Schedule of variations:
            unix

            Running target unix
            Running ../../../gcc/libgo/libgo.exp ...
            FAIL: bufio
            FAIL: bytes
            FAIL: errors
            FAIL: expvar
            FAIL: flag
            FAIL: fmt
            FAIL: html
            FAIL: image
            FAIL: io
            FAIL: log
            FAIL: math
            FAIL: mime
            FAIL: net
            FAIL: os
            FAIL: path
            FAIL: reflect
            FAIL: regexp
            FAIL: runtime
            FAIL: sort
            FAIL: strconv
            FAIL: strings
            FAIL: sync
            FAIL: syscall
            FAIL: time
            FAIL: unicode
            FAIL: archive/tar
            FAIL: archive/zip
            FAIL: compress/bzip2
            FAIL: compress/flate
            FAIL: compress/gzip
            FAIL: compress/lzw
            FAIL: compress/zlib
            FAIL: container/heap
            FAIL: container/list
            FAIL: container/ring
            FAIL: crypto/aes
            FAIL: crypto/cipher
            FAIL: crypto/des
            FAIL: crypto/dsa
            FAIL: crypto/ecdsa
            FAIL: crypto/elliptic
            FAIL: crypto/hmac
            FAIL: crypto/md5
            FAIL: crypto/rand
            FAIL: crypto/rc4
            FAIL: crypto/rsa
            FAIL: crypto/sha1
            FAIL: crypto/sha256
            FAIL: crypto/sha512
            FAIL: crypto/subtle
            FAIL: crypto/tls
            FAIL: crypto/x509
            FAIL: database/sql
            FAIL: database/sql/driver
            FAIL: debug/dwarf
            FAIL: debug/elf
            FAIL: debug/macho
            FAIL: debug/pe
            FAIL: encoding/ascii85
            FAIL: encoding/asn1
            FAIL: encoding/base32
            FAIL: encoding/base64
            FAIL: encoding/binary
            FAIL: encoding/csv
            FAIL: encoding/gob
            FAIL: encoding/hex
            FAIL: encoding/json
            FAIL: encoding/pem
            PASS: encoding/xml
            FAIL: exp/cookiejar
            FAIL: exp/ebnf
            FAIL: exp/html
            FAIL: exp/html/atom
            FAIL: exp/locale/collate
            FAIL: exp/locale/collate/build
            FAIL: exp/norm
            FAIL: exp/proxy
            FAIL: exp/terminal
            FAIL: exp/utf8string
            FAIL: html/template
            FAIL: go/ast
            FAIL: go/doc
            FAIL: go/format
            FAIL: go/parser
            FAIL: go/printer
            FAIL: go/scanner
            FAIL: go/token
            FAIL: go/types
            FAIL: hash/adler32
            FAIL: hash/crc32
            FAIL: hash/crc64
            FAIL: hash/fnv
            FAIL: image/color
            FAIL: image/draw
            FAIL: image/jpeg
            FAIL: image/png
            FAIL: index/suffixarray
            FAIL: io/ioutil
            FAIL: log/syslog
            FAIL: math/big
            FAIL: math/cmplx
            FAIL: math/rand
            FAIL: mime/multipart
            FAIL: net/http
            FAIL: net/http/cgi
            FAIL: net/http/fcgi
            FAIL: net/http/httptest
            FAIL: net/http/httputil
            FAIL: net/mail
            FAIL: net/rpc
            FAIL: net/smtp
            FAIL: net/textproto
            FAIL: net/url
            FAIL: net/rpc/jsonrpc
            FAIL: old/netchan
            FAIL: old/regexp
            FAIL: old/template
            FAIL: os/exec
            FAIL: os/signal
            FAIL: os/user
            FAIL: path/filepath
            FAIL: regexp/syntax
            FAIL: runtime/pprof
            FAIL: sync/atomic
            FAIL: text/scanner
            FAIL: text/tabwriter
            FAIL: text/template
            FAIL: text/template/parse
            FAIL: testing/quick
            FAIL: unicode/utf16
            FAIL: unicode/utf8

                    === libgo Summary ===

# of expected passes        1
# of unexpected failures    130
/root/gcc_new/gccbuild/./gcc/gccgo version 4.9.0 20130606 (experimental) (GCC)
</code></pre></div></div>

<p><strong>Oh boy!</strong> Oh boy! Well, on second thoughts, this was not unexpected. 
<strong>This was the core of my GSOC work</strong>. This is how it starts :)</p>

<p>Before this goes any further, maybe we should visit the Linux test results too.</p>

<div lang="shell" class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Test Run By fotis on Τρι 02 Ιούλ 2013 09:20:20 μμ EEST
Native configuration is i686-pc-linux-gnu

        === libgo tests ===

        Schedule of variations:
            unix

            Running target unix
            Running ../../../gcc/libgo/libgo.exp ...
            PASS: bufio
            PASS: bytes
            ...

                    === libgo Summary ===

# of expected passes        131
/home/fotis/Software/gcc_build/./gcc/gccgo version 4.9.0 20130702 (experimental) (GCC)
</code></pre></div></div>

<p>Wow. Considering the results from the Hurd, they really are <strong>not</strong> unexpected. <a href="http://darnassus.sceen.net/~hurd-web/open_issues/gccgo/">Remember
that <strong>getcontext, makecontext, setcontext and swapcontext</strong> are not working as expected.</a></p>

<p>And recalling from an email from Ian Lance Taylor (the GCCgo maintainer, and a member of the Go team)
early in the summer:</p>

<blockquote>
  <p>Go does require switching stacks.  A port of Go that doesn’t support
goroutines would be useless–nothing in the standard library would
work</p>
</blockquote>

<h1>Conclusion / Work for next week.</h1>

<p><strong>So now it comes down to work on implementing correctly the context switching functions.</strong> 
Apart from that, going through the test results that fail from gccgo is also something that
is to be done, however I am not sure that it should be a first priority. I also have to go
through go.log to see if there any clues as to why the gccgo tests fail.</p>

<p>Having finally built gccgo on the Hurd, and <strong>more importantly still being on schedule,
(the original one, from my proposal) means that I can now concentrate on the core part of my 
project proposal (and the most exciting one too)</strong>, that is proper implementation 
of what is <em>blocking effective context switching, which
in its part is blocking goroutines, without which, the go library will not work properly.</em></p>

        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/5/">&laquo; Older</a>
    

    
      <a class="next" href="/posts/3/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Fotis Koutoulakis - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://nlightnfotis.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
