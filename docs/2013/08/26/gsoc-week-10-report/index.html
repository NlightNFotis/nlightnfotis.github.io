<!DOCTYPE html>
<html lang="en-GB">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>GSOC week 10 report</title>
  <meta name="description" content="Introduction This week was spent attempting to debug the gccgo runtime via print statements. There were many things that I gained from this endeavour. The most significant of which, is the fact that I have got a great deal of information regarding the bootstrapping of a go process. Let’s proceed into presenting this week’s findings, shall we? Findings The process bootstrapping sequence The code that begins a new go-process is conveniently located in a file called go-main.c, the most significant part of which is the following: int main (int argc, char **argv) { runtime_check (); runtime_args (argc, (byte **) argv); runtime_osinit (); runtime_schedinit (); __go_go (mainstart, NULL); runtime_mstart (runtime_m ()); abort (); } static void mainstart (void *arg __attribute__ ((unused))) { runtime_main (); } The process is as follows: First runtime_check runs and registers the os_Args and syscall_Envs as runtime_roots with the garbage collector. I am still investigating what this function exactly is doing, but it seems like some early initialisation of the garbage collector Secondly, runtime_args is run. It’s job is to call a specific argument handler for the arguments passed to main. Thirdly, runtime_osinit is run, whose job is to call the lowlevel _CPU_COUNT function, to get the number of CPUs (in a specific data structure that represents a set of CPUs) After that, runtime_schedinit is run, whose job is to create the very first goroutine (g) and system thread (m), and continues with parsing the command line arguments, and the environment variables. After that it sets the maximum number of cpus that are to be used (via GOMAXPROCS), runs the first goroutine, and does some last pieces of the scheduler’s initialisation. Following runtime_schedinit, __go_go is run, a function whose purpose is to create a new queue, tell it to execute the function that is passed to it as the first parameter, and then queue the goroutine in the global ready-to-run goroutine pool. Last but not least, runtime_mstart runs, which seems to be starting te execution of the kernel thread created during runtime_schedinit. The very last piece of code that is run (and most probably the most important) is runtime_main. Remember that this is passed as a parameter to a goroutine created during the __go_go call, and its job is to mark the goroutine that called it as the main os thread, to initialise the sceduler, and create a goroutine whose job is to release unused memory (from the heap) back to the OS. It then starts executing the process user defined instructions (the code the programmer run) via a call to a macro that directs it to __go_init_main in the assembly generated by the compiler. Runtime_main is also the function that terminates the execution of a go process, with a call to runtime_exit which seems to be a macro to the exit function. Other findings During our debugging sessions we found out that the total count of kernel threads that are running in a simple program is at least two. The first one is the bootstrap M, (the one initialised during the program’s initialisation, inside runtime_schedinit) and at least another one, (I am still invistigating the validity of the following claim) created to be used by the garbage collector. A simple go program such as one doing arithmetic or printing a helloworld like message evidently has no issue running. The issues arrise when we use a go statement. With all our debugging messages activated, this is how a simple go program flows: root@debian:~/Software/Experiments/go# ./a.out [DEBUG] (in main) before runtime_mcheck is run [DEBUG] (in main) before runtime_args is run [DEBUG] (in main) before runtime_osinit is run [DEBUG] (in main) before runtime_schedinit is run [DEBUG] (in main) before runtime_mstart is run [DEBUG] (in runtime_mstart) right before the call to runtime_minit [DEBUG] (in mainstart) right before the call to runtime_main [DEBUG] (in runtime_main) Beginning of runtime_main [DEBUG] (start of runtime_newm) Total number of m&#39;s is 1 [DEBUG] (in runtime_newm) Preparing to create a new thread [DEBUG] (in runtime_newm) Right before the call to pthread_create [DEBUG] (in runtime_newm) pthread_create returned 0 [DEBUG] (in runtime_mstart) right before the call to runtime_minit [DEBUG] (end of runtime_newm) Total number of m&#39;s is 2 Hello, fotis [DEBUG] (in runtime_main) Right before runtime_exit And this is how a goroutine powered program fails: root@debian:~/Software/Experiments/go# ./a.out [DEBUG] (in main) before runtime_mcheck is run [DEBUG] (in main) before runtime_args is run [DEBUG] (in main) before runtime_osinit is run [DEBUG] (in main) before runtime_schedinit is run [DEBUG] (in main) before runtime_mstart is run [DEBUG] (in runtime_mstart) right before the call to runtime_minit [DEBUG] (in mainstart) right before the call to runtime_main [DEBUG] (in runtime_main) Beginning of runtime_main [DEBUG] (start of runtime_newm) Total number of m&#39;s is 1 [DEBUG] (in runtime_newm) Preparing to create a new thread [DEBUG] (in runtime_newm) Right before the call to pthread_create [DEBUG] (in runtime_newm) pthread_create returned 0 [DEBUG] (in runtime_mstart) right before the call to runtime_minit [DEBUG] (end of runtime_newm) Total number of m&#39;s is 2 [DEBUG] (start of runtime_new) Total number of m&#39;s is 2 [DEBUG] (in runtime_newm) Preparing to create a new thread. [DEBUG] (in runtime_newm) Right before the call to pthread_create a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&amp;gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })&#39; failed. Aborted Work for the next week I will of course continue to print debug until I have knowledge of the exact flow of execution in the go runtime. Right now I have very good knowledge of the flow, but there are some things that I need to sort out. For instance it is not exactly clear to me why we call certain functions, or what they are supposed to be doing at certain parts. After I sort this out, I also plan to start debugging the libpthread to see what’s libpthreads status during a hello world like program, and during a goroutine powered program, to get to see if we get to find something interesting in libpthread (like how many threads does libpthread report against how many the goruntime reports)">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://nlightnfotis.github.io/2013/08/26/gsoc-week-10-report/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Lambda reflections" href="https://nlightnfotis.github.io/feed.xml">

  

  
  <meta property="og:title" content="GSOC week 10 report">
  <meta property="og:site_name" content="Lambda reflections">
  <meta property="og:url" content="https://nlightnfotis.github.io/2013/08/26/gsoc-week-10-report/">
  <meta property="og:description" content="Introduction This week was spent attempting to debug the gccgo runtime via print statements. There were many things that I gained from this endeavour. The most significant of which, is the fact that I have got a great deal of information regarding the bootstrapping of a go process. Let’s proceed into presenting this week’s findings, shall we? Findings The process bootstrapping sequence The code that begins a new go-process is conveniently located in a file called go-main.c, the most significant part of which is the following: int main (int argc, char **argv) { runtime_check (); runtime_args (argc, (byte **) argv); runtime_osinit (); runtime_schedinit (); __go_go (mainstart, NULL); runtime_mstart (runtime_m ()); abort (); } static void mainstart (void *arg __attribute__ ((unused))) { runtime_main (); } The process is as follows: First runtime_check runs and registers the os_Args and syscall_Envs as runtime_roots with the garbage collector. I am still investigating what this function exactly is doing, but it seems like some early initialisation of the garbage collector Secondly, runtime_args is run. It’s job is to call a specific argument handler for the arguments passed to main. Thirdly, runtime_osinit is run, whose job is to call the lowlevel _CPU_COUNT function, to get the number of CPUs (in a specific data structure that represents a set of CPUs) After that, runtime_schedinit is run, whose job is to create the very first goroutine (g) and system thread (m), and continues with parsing the command line arguments, and the environment variables. After that it sets the maximum number of cpus that are to be used (via GOMAXPROCS), runs the first goroutine, and does some last pieces of the scheduler’s initialisation. Following runtime_schedinit, __go_go is run, a function whose purpose is to create a new queue, tell it to execute the function that is passed to it as the first parameter, and then queue the goroutine in the global ready-to-run goroutine pool. Last but not least, runtime_mstart runs, which seems to be starting te execution of the kernel thread created during runtime_schedinit. The very last piece of code that is run (and most probably the most important) is runtime_main. Remember that this is passed as a parameter to a goroutine created during the __go_go call, and its job is to mark the goroutine that called it as the main os thread, to initialise the sceduler, and create a goroutine whose job is to release unused memory (from the heap) back to the OS. It then starts executing the process user defined instructions (the code the programmer run) via a call to a macro that directs it to __go_init_main in the assembly generated by the compiler. Runtime_main is also the function that terminates the execution of a go process, with a call to runtime_exit which seems to be a macro to the exit function. Other findings During our debugging sessions we found out that the total count of kernel threads that are running in a simple program is at least two. The first one is the bootstrap M, (the one initialised during the program’s initialisation, inside runtime_schedinit) and at least another one, (I am still invistigating the validity of the following claim) created to be used by the garbage collector. A simple go program such as one doing arithmetic or printing a helloworld like message evidently has no issue running. The issues arrise when we use a go statement. With all our debugging messages activated, this is how a simple go program flows: root@debian:~/Software/Experiments/go# ./a.out [DEBUG] (in main) before runtime_mcheck is run [DEBUG] (in main) before runtime_args is run [DEBUG] (in main) before runtime_osinit is run [DEBUG] (in main) before runtime_schedinit is run [DEBUG] (in main) before runtime_mstart is run [DEBUG] (in runtime_mstart) right before the call to runtime_minit [DEBUG] (in mainstart) right before the call to runtime_main [DEBUG] (in runtime_main) Beginning of runtime_main [DEBUG] (start of runtime_newm) Total number of m&#39;s is 1 [DEBUG] (in runtime_newm) Preparing to create a new thread [DEBUG] (in runtime_newm) Right before the call to pthread_create [DEBUG] (in runtime_newm) pthread_create returned 0 [DEBUG] (in runtime_mstart) right before the call to runtime_minit [DEBUG] (end of runtime_newm) Total number of m&#39;s is 2 Hello, fotis [DEBUG] (in runtime_main) Right before runtime_exit And this is how a goroutine powered program fails: root@debian:~/Software/Experiments/go# ./a.out [DEBUG] (in main) before runtime_mcheck is run [DEBUG] (in main) before runtime_args is run [DEBUG] (in main) before runtime_osinit is run [DEBUG] (in main) before runtime_schedinit is run [DEBUG] (in main) before runtime_mstart is run [DEBUG] (in runtime_mstart) right before the call to runtime_minit [DEBUG] (in mainstart) right before the call to runtime_main [DEBUG] (in runtime_main) Beginning of runtime_main [DEBUG] (start of runtime_newm) Total number of m&#39;s is 1 [DEBUG] (in runtime_newm) Preparing to create a new thread [DEBUG] (in runtime_newm) Right before the call to pthread_create [DEBUG] (in runtime_newm) pthread_create returned 0 [DEBUG] (in runtime_mstart) right before the call to runtime_minit [DEBUG] (end of runtime_newm) Total number of m&#39;s is 2 [DEBUG] (start of runtime_new) Total number of m&#39;s is 2 [DEBUG] (in runtime_newm) Preparing to create a new thread. [DEBUG] (in runtime_newm) Right before the call to pthread_create a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&amp;gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })&#39; failed. Aborted Work for the next week I will of course continue to print debug until I have knowledge of the exact flow of execution in the go runtime. Right now I have very good knowledge of the flow, but there are some things that I need to sort out. For instance it is not exactly clear to me why we call certain functions, or what they are supposed to be doing at certain parts. After I sort this out, I also plan to start debugging the libpthread to see what’s libpthreads status during a hello world like program, and during a goroutine powered program, to get to see if we get to find something interesting in libpthread (like how many threads does libpthread report against how many the goruntime reports)">
  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="NlightNFotis">
  <meta name="twitter:title" content="GSOC week 10 report">
  <meta name="twitter:description" content="Introduction This week was spent attempting to debug the gccgo runtime via print statements. There were many things that I gained from this endeavour. The most significant of which, is the fact tha...">
  
    <meta name="twitter:creator" content="NlightNFotis">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Lambda reflections</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/NlightNFotis">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">GSOC week 10 report</h1>
    
    <p class="post-meta"><time datetime="2013-08-26T09:00:00+00:00" itemprop="datePublished">Aug 26, 2013</time>

 •
  
    
    
      
        <a href="/tags/gsoc/">gsoc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
        <a href="/tags/gcc/">gcc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/tags/golang/">golang</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1>Introduction</h1>

<p>This week was spent attempting to debug the gccgo runtime via print statements. There were many things
that I gained from this endeavour. The most significant of which, is the fact that I have got a great
deal of information regarding the bootstrapping of a go process. Let’s proceed into presenting this 
week’s findings, shall we?</p>

<h1>Findings</h1>

<h2>The process bootstrapping sequence</h2>

<p>The code that begins a new go-process is conveniently located in a file called <code class="language-plaintext highlighter-rouge">go-main.c</code>, the most significant
part of which is the following:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">runtime_check</span> <span class="p">();</span>
  <span class="n">runtime_args</span> <span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="p">(</span><span class="n">byte</span> <span class="o">**</span><span class="p">)</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">runtime_osinit</span> <span class="p">();</span>
  <span class="n">runtime_schedinit</span> <span class="p">();</span>
  <span class="n">__go_go</span> <span class="p">(</span><span class="n">mainstart</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">runtime_mstart</span> <span class="p">(</span><span class="n">runtime_m</span> <span class="p">());</span>
  <span class="n">abort</span> <span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mainstart</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">unused</span><span class="p">)))</span>
<span class="p">{</span>
  <span class="n">runtime_main</span> <span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p>The process is as follows:</p>

<ul>
  <li>First <code class="language-plaintext highlighter-rouge">runtime_check</code> runs and registers the os_Args and syscall_Envs as runtime_roots with the garbage collector. I am still investigating what this function exactly is doing, but it seems like some early initialisation of the garbage collector</li>
  <li>Secondly, <code class="language-plaintext highlighter-rouge">runtime_args</code> is run. It’s job is to call a specific argument handler for the arguments passed to <code class="language-plaintext highlighter-rouge">main</code>.</li>
  <li>Thirdly, <code class="language-plaintext highlighter-rouge">runtime_osinit</code> is run, whose job is to call the lowlevel _CPU_COUNT function, to get the number of CPUs (in a specific data structure that represents a set of CPUs)</li>
  <li>After that, <code class="language-plaintext highlighter-rouge">runtime_schedinit</code> is run, whose job is to create the very first goroutine (g) and system thread (m), and continues with parsing the command line arguments, and the environment variables. After that it sets the maximum number of cpus that are to be used (via <code class="language-plaintext highlighter-rouge">GOMAXPROCS</code>), runs the first goroutine, and does some last pieces of the scheduler’s initialisation.</li>
  <li>Following <code class="language-plaintext highlighter-rouge">runtime_schedinit</code>, <code class="language-plaintext highlighter-rouge">__go_go</code> is run, a function whose purpose is to create a new queue, tell it to execute the function that is passed to it as the first parameter, and then queue the goroutine in the
global ready-to-run goroutine pool.</li>
  <li>Last but not least, <code class="language-plaintext highlighter-rouge">runtime_mstart</code> runs, which seems to be starting te execution of the kernel thread created during <code class="language-plaintext highlighter-rouge">runtime_schedinit</code>.</li>
</ul>

<p>The very last piece of code that is run (and most probably the most important) is <code class="language-plaintext highlighter-rouge">runtime_main</code>. Remember that this is passed as a parameter to a goroutine created during the <code class="language-plaintext highlighter-rouge">__go_go</code> call, and its job is to mark the goroutine that called it as <em>the main os thread</em>, to initialise the sceduler, and create a goroutine whose job is to release unused memory (from the heap) back to the OS.
It then starts executing the process user defined instructions (the code the programmer run) via a call to a
macro that directs it to <code class="language-plaintext highlighter-rouge">__go_init_main</code> in the assembly generated by the compiler.</p>

<p><code class="language-plaintext highlighter-rouge">Runtime_main</code> is also the function that terminates the execution of a go process, with a call to <code class="language-plaintext highlighter-rouge">runtime_exit</code>
which seems to be a macro to the <code class="language-plaintext highlighter-rouge">exit</code> function.</p>

<h2>Other findings</h2>

<p>During our debugging sessions we found out that the total count of kernel threads that are running in a simple program is at least two.
The first one is the bootstrap M, (the one initialised during the program’s initialisation, inside <code class="language-plaintext highlighter-rouge">runtime_schedinit</code>) and at least another one, (I am still invistigating the validity of the following claim) 
created to be used by the garbage collector.</p>

<p>A simple go program such as one doing arithmetic or printing a helloworld like message evidently has no issue
running.
The issues arrise when we use a <code class="language-plaintext highlighter-rouge">go statement</code>. With all our debugging messages activated, this is how a simple
go program flows:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">root@debian:~/Software/Experiments/go# ./a.out
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_mcheck is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_args is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_osinit is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_schedinit is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_mstart is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>runtime_mstart<span class="o">)</span> right before the call to runtime_minit
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>mainstart<span class="o">)</span> right before the call to runtime_main
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>runtime_main<span class="o">)</span> Beginning of runtime_main
<span class="o">[</span>DEBUG] <span class="o">(</span>start of runtime_newm<span class="o">)</span> Total number of m<span class="s1">'s is 1
[DEBUG] (in runtime_newm) Preparing to create a new thread
[DEBUG] (in runtime_newm) Right before the call to pthread_create
[DEBUG] (in runtime_newm) pthread_create returned 0
[DEBUG] (in runtime_mstart) right before the call to runtime_minit
[DEBUG] (end of runtime_newm) Total number of m'</span>s is 2
Hello, fotis
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>runtime_main<span class="o">)</span> Right before runtime_exit</code></pre></figure>

<p>And this is how a goroutine powered program fails:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">root@debian:~/Software/Experiments/go# ./a.out
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_mcheck is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_args is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_osinit is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_schedinit is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>main<span class="o">)</span> before runtime_mstart is run
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>runtime_mstart<span class="o">)</span> right before the call to runtime_minit
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>mainstart<span class="o">)</span> right before the call to runtime_main
<span class="o">[</span>DEBUG] <span class="o">(</span><span class="k">in </span>runtime_main<span class="o">)</span> Beginning of runtime_main
<span class="o">[</span>DEBUG] <span class="o">(</span>start of runtime_newm<span class="o">)</span> Total number of m<span class="s1">'s is 1
[DEBUG] (in runtime_newm) Preparing to create a new thread
[DEBUG] (in runtime_newm) Right before the call to pthread_create
[DEBUG] (in runtime_newm) pthread_create returned 0
[DEBUG] (in runtime_mstart) right before the call to runtime_minit
[DEBUG] (end of runtime_newm) Total number of m'</span>s is 2
<span class="o">[</span>DEBUG] <span class="o">(</span>start of runtime_new<span class="o">)</span> Total number of m<span class="s1">'s is 2
[DEBUG] (in runtime_newm) Preparing to create a new thread.
[DEBUG] (in runtime_newm) Right before the call to pthread_create
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })'</span> failed.
Aborted</code></pre></figure>

<h1>Work for the next week</h1>

<p>I will of course continue to print debug until I have knowledge of the exact flow of execution in the go
runtime. Right now I have very good knowledge of the flow, but there are some things that I need to sort out.
For instance it is not exactly clear to me why we call certain functions, or what they are supposed to be doing at certain parts. After I sort this out,  I also plan to start debugging the libpthread to see what’s libpthreads status
during a hello world like program, and during a goroutine powered program, to get to see if we get
to find something interesting in libpthread (like how many threads does libpthread report against how
many the goruntime reports)</p>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Fotis Koutoulakis - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://nlightnfotis.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
