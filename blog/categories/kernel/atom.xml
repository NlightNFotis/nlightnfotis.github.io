<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | Fotis Koutoulakis]]></title>
  <link href="http://NlightNFotis.github.io/blog/categories/kernel/atom.xml" rel="self"/>
  <link href="http://NlightNFotis.github.io/"/>
  <updated>2014-04-25T19:41:20+03:00</updated>
  <id>http://NlightNFotis.github.io/</id>
  <author>
    <name><![CDATA[Fotis Koutoulakis]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How the compiler, the Library and the Kernel work - Part 2 ]]></title>
    <link href="http://NlightNFotis.github.io/blog/2014/04/25/how-the-compiler/"/>
    <updated>2014-04-25T18:27:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2014/04/25/how-the-compiler</id>
    <content type="html"><![CDATA[<p>In the previous part of this little series, we talked about the compiler, and what it does
with the header files, in our attempt to demistify their usage. In this part, I want to show you
what&rsquo;s the compiler&rsquo;s output, and how we create our file.</p>

<h1>The compiler&rsquo;s composition</h1>

<p>Generally speaking, a <em>compiler</em> belongs to a family of software called <strong>translators</strong>.
A translator&rsquo;s job is to read some source code in a source language, and generate (translate it to)
some source code in a target language.</p>

<p>Now, you might think that most compilers you know don&rsquo;t do that. You input a (source code) file,
and you get a binary file, ready to run when you want it to. Yes that&rsquo;s what it does, but it&rsquo;s not
the compiler that does all this. If you remember from the last installment of this series,
when you call the compiler like <code>gcc some_file.c</code> or <code>clang some_file.c</code>, in essence you are
calling the compilation driver, with the file as a parameter. The compilation driver then calls
1) the preprocessor, 2) the (actual) compiler, 3) the assembler and last but not least the linker.
At least when it comes to gcc, these pieces of software are called <code>cpp</code>, <code>cc1</code>,
<code>gas</code> (executable name is <code>as</code>)  and <code>collect2</code> (executable name is <code>ld</code>) respectively.</p>

<p>From that little software collection up top, that we call the compiler, we can easily take notice
of at least 3 (yeah, that&rsquo;s right) translators, that act as we mentioned earlier,
that is take some input in a source language, and produce some output to a target language.</p>

<p>The first is the preprocessor. The preprocessor accepts source code in C as a source language,
and produces source code again in C (as a target language), but with the output having various
elements of the source code resolved, such as header file inclusion, macro expansion, etc.</p>

<p>The second is the compiler. The compiler accepts (in our case) C source code, as a source language,
and translates it to some architecture&rsquo;s assembly language. In my case, when I talk about the
compiler, I&rsquo;m gonna assume that it produces x86 assembly.</p>

<p>The last one, is the assembler, which accepts as input some machine&rsquo;s architecture assembly
language, and produces what&rsquo;s called binary, or object representation of it, that is it translates
the assembly mnemonics directly to the bytes they correspond to, in the target architecture.</p>

<p>At this point, one could also argue that the linker is also a translator, accepting binary, and
translating it to an executable file, that is, resolving references, and fitting the binary code
on the segments of the file that is to be produced. For example, on a typical GNU/Linux system,
this phase produces the executable ELF file.</p>

<h1>The (actual) compiler&rsquo;s output: x86 assembly.</h1>

<p>Before we go any further, I would like to show you what the compiler really creates:</p>

<p>For the typical hello world program we demonstrated in our first installment, the compiler
will output the following assembly code:</p>

<p>``` gas hello.S</p>

<pre><code>.file   "hello.c"
.section    .rodata
</code></pre>

<p>.LC0:</p>

<pre><code>.string "Hello world!"
.text
.globl  main
.type   main, @function
</code></pre>

<p>main:</p>

<pre><code>pushq   %rbp
movq    %rsp, %rbp
subq    $16, %rsp
movl    %edi, -4(%rbp)
movq    %rsi, -16(%rbp)
movl    $.LC0, %edi
call    puts
movl    $0, %eax
leave
ret
.size   main, .-main
.ident  "GCC: (GNU) 4.8.2 20131212 (Red Hat 4.8.2-7)"
.section    .note.GNU-stack,"",@progbits
</code></pre>

<p>```</p>

<p>To produce the above file, we had to use the following gcc invocation command:
<code>gcc -S -fno-asynchronous-unwind-tables -o hello.S hello.c</code>.
We used <code>-fno-asynchronous-unwind-tables</code> to remove <code>.cfi</code> directives, which tell <code>gas</code>
(the gnu assembler) to emit Dwarf Call Frame Information tags, which are used to reconstruct
a stack backtrace when a frame pointer is missing.</p>

<p>For more usefull compilation flags, to control the intermediary compilation flow, try these:</p>

<ul>
<li><code>-E</code>: stop after preprocessing, and produce a *.i file</li>
<li><code>-S</code>: we used this, stop after the compiler, and produce a *.s file</li>
<li><code>-c</code>: stop after the assembler, and produce a *.o file.</li>
</ul>


<p>The default behaviour is to use none, and stop after the linker has run. If you want to run a
full compilation and keep all the intermediate files, use the <code>-save-temps</code> flag.</p>

<h1>From source to binary: the assembler.</h1>

<p>The next part of the compilation process, is the assembler. We have already discussed what
the assembler does, so here we are going to see it in practice. If you have followed so far,
you should have two files, a <code>hello.c</code>, which is the hello world&rsquo;s C source code file,
and a <code>hello.S</code> which is what we created earlier, the compiler&rsquo;s (x86) assembly output.</p>

<p>The assembler operates on that last file as you can imagine, and to see it running, and emit
binary, we need to invoke it like this: <code>as -o hello.bin hello.S</code>, and produces this:</p>

<p>``` objdump hello.bin</p>

<p>ELF\00\00\00\00\00\00\00\00\00\00>\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\F0\00\00\00\00\00\00\00\00\00\00\00@\00\00\00\00\00@\00\00\00UH\89\E5H\83\EC\89}\FCH\89u\F0\BF\00\00\00\00\E8\00\00\00\00\B8\00\00\00\00\C9\C3Hello world!\00\00GCC: (GNU) 4.8.2 20131212 (Red Hat 4.8.2-7)\00\00.symtab\00.strtab\00.shstrtab\00.rela.text\00.data\00.bss\00.rodata\00.comment\00.note.GNU-stack\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00@\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\B8\00\00\00\00\00\000\00\00\00\00\00\00\00   \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00&amp;\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00<code>\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00,\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00</code>\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\001\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00`\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\009\00\00\00\00\00\000\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00m\00\00\00\00\00\00\00-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00B\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\9A\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\9A\00\00\00\00\00\00\00R\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\B0\00\00\00\00\00\00\F0\00\00\00\00\00\00\00
\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00    \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\A0\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\F1\FF\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00hello.c\00main\00puts\00\00\00\00\00\00\00\00\00\00\00\00\00
\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00    \00\00\00\FC\FF\FF\FF\FF\FF\FF\FF
```</p>

<h1>Last but not least: the linker</h1>

<p>We saw what the assembler emits, which is to say, binary code. However, that binary code
still needs further processing. To explain that, we need to go back a little.</p>

<p>In our first installment of the series, we said that when you call a function like <code>printf()</code>,
the compiler only needs its prototype to do type checking and ensure that you use it legally.
For that you include the header file <code>stdio.h</code>. But since that contains the function prototype only,
where is the source code for that function? Surely, it must be somewhere, since it executes
successfully to begin with, but we haven&rsquo;t met the source code for printf so far, so where is it?</p>

<p>The function&rsquo;s source code is located in the <code>.so</code> (shared object) of the standard C library,
which in my system (Fedora 19, x64) is <code>libc-2.17.so</code>. I don&rsquo;t want to expand on that further,
as I plan to do so on the next series installment, however, what we have said so far is enough
for you to understand the linker&rsquo;s usage:</p>

<p>The linker resolves the undefined (thus far) reference to printf, by finding the reference to
the printf symbol and (in layman&rsquo;s talk)
making a pointer to point to it so that execution can jump to printf&rsquo;s code
when we have to do that during our program&rsquo;s execution.</p>

<p>To invoke the linker on our file, <a href="https://sourceware.org/binutils/docs-2.20/ld/Options.html#Options">at least according to it&rsquo;s documentation</a>,
we should do the following: <code>ld -o hello.out /lib/crt0.o hello.bin -lc</code>. Then we should
be able to run the file like this: <code>./hello.out</code>.</p>

<h1>Epilogue</h1>

<p>That&rsquo;s this end of this part 2 of my series that explains how your code turns into binary, and how
your computer (at least when it comes to the software side) runs it. In part 3, I am going to discuss
in greater length, the C library, and the kernel.</p>

<h2>References</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/3564752/what-is-cfi-and-lfe-in-assembly-code-produced-by-gcc-from-c-program">StackOverflow: What is .cfi and .LFE in assembly code produced by GCC from c++ program?</a></li>
<li><a href="http://blog.lxgcc.net/?p=181">GCC front-end (1): driver vs. compiler</a></li>
<li><a href="http://wiki.osdev.org/GAS">GAS</a></li>
<li><a href="https://sourceware.org/binutils/docs-2.20/ld/"> ld: Binutils documentation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How the compiler, the Library and the kernel work - Part 1]]></title>
    <link href="http://NlightNFotis.github.io/blog/2013/12/12/how-the-compiler/"/>
    <updated>2013-12-12T16:13:00+02:00</updated>
    <id>http://NlightNFotis.github.io/blog/2013/12/12/how-the-compiler</id>
    <content type="html"><![CDATA[<p>Before we get any further, it might be good if we provided some context.</p>

<h1>Hello world. Again.</h1>

<p>```c helloworld.c</p>

<h1>include &lt;stdio.h></h1>

<p>int
main (int argc, char **argv)
{</p>

<pre><code>printf ("Hello world!\n");

return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>Every user space programmer, has written a hello world program. Only god knows how many times this program
has been written. Yet, most programmers' knowledge of the program is limited to something along the lines of:</p>

<blockquote><ul>
<li>It sends the string passed as a parameter to the system to print.</li>
<li>It takes the printf function from stdio.h and prints the string</li>
</ul>
</blockquote>

<p>and various other things, which are anywhere between plain wrong, or partially correct.</p>

<p><strong> So why not demistify the process? </strong></p>

<h1>Enter the C preprocessor.</h1>

<p>You may have heard of the C Preprocessor. It&rsquo;s the first stage of a c or c++ file compilation,
and it&rsquo;s actually responsible for things such as <strong>inclusion of header files</strong> (it does so by replacing
<code>#include &lt;header.h&gt;</code> with the content of this file, and the file it includes recursively),
<strong>macro expansion</strong> (such as the famous comparison of two numbers (a greater than b)
<code>#define gt(a, b) ((a &gt;= b) ? 1 : 0)</code>), <strong>conditional compilation</strong> (things such as:</p>

<p>```c</p>

<h1>ifdef WIN32</h1>

<pre><code>printf ("We are on windows\n"); 
</code></pre>

<h1>endif</h1>

<p>```</p>

<p>amongst others. You can see it for yourself. Write the hello world program, and pass it to cpp: <code>cpp hello_world.c</code></p>

<p>So now that we know what it does it&rsquo;s time to demistify a common myth regarding it: <em>Some people believe
that the header files include the function to be called.</em>. <strong>That&rsquo;s wrong.</strong> What it does include is
<strong>function prototypes</strong> (and some type definitions, etc) <strong>only</strong>. It doesn&rsquo;t include the body of the function
to be called.</p>

<p>Some people are quite surprised by that fact. In fact, it isn&rsquo;t, if you get to understand what the compiler
does with it.</p>

<h1>Say hello to the compiler.</h1>

<p>Here we are gonna unmask another pile of misconceptions. First of all, some people think that when they call
<code>gcc</code> on the command line they are actually calling the compiler. <strong>They are not.</strong> <em>In fact they are calling
the software commonly called <strong>the compilation driver</strong>, whose job is to run all the software needed to fully
turn source to binary, including preprocessors, the actual compiler, an assembler and finally the linker</em></p>

<p>Having said that, the actual compiler that&rsquo;s getting called when you call <code>gcc</code> is called <code>cc1</code>. You may have seen it some times when the driver reports errors. Wanna take a look at it, to make sure I&rsquo;m not lying to you?
(Hint: I&rsquo;m not!) Fair enough. Why don&rsquo;t you type this in the command line: <code>gcc -print-prog-name=cc1</code>. It should tell you where the actual compiler is located in your system.</p>

<p>So now that we have this (misconception) out of our minds, we can continue with our analysis. Last time we talked
about it, we said that the header files include <strong>prototypes</strong> and not the whole function.</p>

<p>You may know that in C, you usually declare a function, before you use it. The primary reason for doing this
is to provide the compiler with the ability to perform <strong>type checking</strong>, that is to check that the arguments
passed are correct, both in number, and in type, and to verify that the returned value (assuming there is one)
is being used correctly. Below is a program that demonstrates the function prototype:</p>

<p>```c prototype.c</p>

<h1>include &lt;stdio.h></h1>

<p>int add_nums (int first, int second)</p>

<p>int
main (void)
{</p>

<pre><code>printf ("5 + 5 results in %d\n", add_nums (5, 5));

return 0;
</code></pre>

<p>}</p>

<p>int
add_nums (int first, int second)
{</p>

<pre><code>return first + second;
</code></pre>

<p>}
```</p>

<p>In this particular example, the prototype gives the compiler a wide variety of information. It tells it
that function <code>add_nums</code> takes two int arguments and returns an integer to the calling function. Now the
compiler can verify that I am passing correct arguments to it when I call it inside printf. If I don&rsquo;t include
the function prototype, and do something slightly evil such as calling <code>add_nums</code> with <code>float</code> arguments then
this might happen:</p>

<p><code>
5 + 4 results in 2054324224
</code></p>

<p>Now that you know that the compiler (the real one) only needs the prototype and not the actual function code,
you may be wondering how the compiler actually compiles it if it doesn&rsquo;t know it&rsquo;s code.</p>

<p>Now is the time to bring down another missconception. The word <em>compiler</em> is just a fancy name for software
otherwise known as <em>translators</em>. A <em>translator&rsquo;s</em> job is to get input and turn it from one language (source language) to a second language (target language), whatever that may be. Most of the times, when you compile software,
you compile it to run in your computer, which runs on a processor from the x86 architecture family of processors.
A processor is typically associated with an assembly language for that architecture (which is just human friendly
mnemonics for common processor tasks), so your <em>x86 computer runs x86 assembly</em> (ok that&rsquo;s not 100% true, but for
simplicity&rsquo;s sake at the moment, it should serve. We will see why it&rsquo;s not true later.) So the compiler
(in a typical translation) translates (compiles) your C source code to x86 assembly.
You can see this by compiling your hello world example and passing the compiler the <code>-S</code> (which asks it to stop,
after x86 assembly is produced) parameter, likewise <code>gcc -S hello.c</code>.</p>

<h1>Conclusion</h1>

<p>At this part, we saw how the compiler and the preprocessor work with our code, in an attempt to demistify the
so called library calls. In the next part, we are going to study the assembler and the linker, and for the final
part the loader and the kernel.</p>
]]></content>
  </entry>
  
</feed>
