<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: kernel | Fotis Koutoulakis]]></title>
  <link href="http://NlightNFotis.github.io/blog/categories/kernel/atom.xml" rel="self"/>
  <link href="http://NlightNFotis.github.io/"/>
  <updated>2014-07-29T15:47:35+03:00</updated>
  <id>http://NlightNFotis.github.io/</id>
  <author>
    <name><![CDATA[Fotis Koutoulakis]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How the Compiler, the Library and the Kernel work - Part 3]]></title>
    <link href="http://NlightNFotis.github.io/blog/2014/06/20/how-the-compiler/"/>
    <updated>2014-06-20T20:49:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2014/06/20/how-the-compiler</id>
    <content type="html"><![CDATA[<p>In the last part of this series, we talked about the compiler‚Äôs composition, including the assembler
and the linker. We showed what happens when the compiler runs, and what‚Äôs the output
of translation software such as <code>cc1</code> or <code>as</code> etc. In this final part of the series, we are going
to talk about the C library, how our programs interface with it, and how it interfaces with 
the kernel.</p>

<h1 id="the-c-standard-library">The C Standard Library</h1>

<p>The C Standard Library is pretty much a part of every UNIX like operating system. It‚Äôs basically
a collection of code, including functions, macros, type definitions etc, in order to provide facilities
such as string handling (<code>string.h</code>), mathematical computations (<code>math.h</code>), input and output
(<code>stdio.h</code>), etc.</p>

<p>GNU/Linux operating systems are generally using the <a href="http://www.gnu.org/software/libc/libc.html">GNU C Library implementation(GLIBC)</a>,
but it‚Äôs common to find other C libraries being used (especially in embedded systems) such as 
<a href="http://www.uclibc.org">uClibC</a>, <a href="http://sources.redhat.com/newlib">newlib</a>, or in the case
of Android/Linux systems <a href="https://android.googlesource.com/platform/bionic.git">Bionic</a>.
BSD style operating systems usually have their own implementation of a C library.</p>

<h2 id="so-how-does-one-use-the-c-standard-library">So, how does one ‚Äúuse‚Äù the C Standard Library?</h2>

<p>So, now that we are acquainted with the C Library, how do you make use of it, you ask? The answer is:
<strong>automagically</strong> :). Hold on right there; that‚Äôs not exactly a hyperbole. You see, when you
write a basic C program, you usually <code>#include &lt;some_header.h&gt;</code> and then continue with
using the code declared in that header. We have explained in the previous part of this series
that when we use a function, say <code>printf()</code>, in reality it‚Äôs the linker that does the hard work 
and allows us to use this function, by linking our program against the <code>libc</code>‚Äôs <code>so</code> (shared 
object). So in essence, when you need to use the C Standard Library, you just <code>#include</code>
headers that belong to it, and the linker will resolve the references to the code included.</p>

<p>Apart from the functions that are defined in the Standards however, a C Library might also
implement further functionality. For example, the Standards don‚Äôt say anything about networking.
As a matter of fact, most libraries today may implement not only what‚Äôs in the C Standards,
but may also choose to comply with the requirements of the POSIX C library, which is a superset
of the C Standard library.</p>

<h2 id="ok-and-how-does-the-c-library-manage-to-provide-these-services">Ok, and how does the C Library manage to provide these services?</h2>

<p>The answer to this question is simple: Some of the services that the library provides, it does so
without needing any sort of special privileges, being normal, userspace C code, while others
need to ask the Operating‚Äôs system Kernel to provide these facilities for the library.</p>

<p>How does it do so? By calling some functions exported by the kernel to provide certain functionality
 named <strong>system calls</strong>. System calls are the fundamental interface between a userspace
application and the Operating System Kernel. For example consider this:</p>

<p>You might have a program that has code like this at one point: <code>fd = open("log.txt", "w+");</code>. That
<code>open</code> function is provided by the C Library, but the C Library itself can not execute all of the
functionality that‚Äôs required to open a file, so it may call a <code>sys_open()</code> system call that will
ask the kernel to do what‚Äôs required to load the file. In this case we say that the library‚Äôs <code>open</code>
call acts as a wrapper function of the system call.</p>

<h1 id="epilogue">Epilogue</h1>

<p>In this final part of our series, we saw how our applications interface with the C Standard Library
available in our system, and how the Library itself interfaces with the Operating system kernel
to provide the required services needed by the userspace applications.</p>

<h2 id="further-reading">Further Reading:</h2>

<p>If you want to take a look at the System Call interface in the Linux Operating System, you could
always see the <a href="http://man7.org/linux/man-pages/man2/syscalls.2.html">man page for the Linux system calls</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to xv6: Adding a new system call.]]></title>
    <link href="http://NlightNFotis.github.io/blog/2014/04/28/introduction-to-xv6-adding-a-new-system-call/"/>
    <updated>2014-04-28T18:24:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2014/04/28/introduction-to-xv6-adding-a-new-system-call</id>
    <content type="html"><![CDATA[<h1 id="xv6-an-introduction">xv6: An introduction</h1>

<p>If you are like me, a low level pc programmer, it‚Äôs hard not to have heard
of <strong>xv6</strong>. <a href="http://pdos.csail.mit.edu/6.828/2012/xv6.html">xv6</a>, for those
who haven‚Äôt really heard of it, is a <em>UNIX version 6</em> clone, designed
at MIT to help teach operating systems. </p>

<p>The reasoning behind doing this was fairly simple: <a href="http://www.lemis.com/grog/Documentation/Lions/">Up until that point, MIT
had used John Lions‚Äô famous commentary on the Sixth Edition of UNIX</a>. But V6 was challenging due to a 
number of reasons. To begin with, it was written in a near ancient version
of C (pre K&amp;R), and apart from that, it contained PDP-11 assembly
(a legendary machine for us UNIX lovers, but ancient nonetheless), which
didn‚Äôt really help the students that had to study both PDP-11 and the
(more common) x86 architecture to develop another (exokernel) operating
system on. </p>

<p>So, to make things much more simpler, professors there decided to 
roll with a clone of UNIX version 6, that was x86 specific, 
written in ANSI C and supported multiprocessor machines.</p>

<p>For a student (or a programmer interested in operating systems), xv6 is 
a unique opportunity to introduce himself to kernel hacking and to the
architecture of UNIX like systems. At about 15k lines of code (iirc), 
including the (primitive) libraries, the userland and the kernel,
it‚Äôs very easy (or well, at least easier than production scale UNIX like
systems) to grok, and it‚Äôs also very easy to expand on. It also helps
tremendously that xv6 as a whole has magnificent documentation, not only
from MIT, but from other universities that have adopted xv6 for use in their
operating systems syllabus.</p>

<h2 id="an-introduction-to-ensidia-my-very-personal-xv6-fork">An introduction to Ensidia: my very personal xv6 fork</h2>

<p>When I first discovered xv6 I was ecstatic. For the reasons mentioned above
I couldn‚Äôt lose on the opportunity to fork xv6 and use it as a personal
testbed for anything I could feel like exploring or testing out.</p>

<p>As a matter of fact, when I first discovered xv6, <a href="https://github.com/NlightNFotis/Fotix">I had just finished 
implementing (the base of) my own UNIX like operating system, named fotix</a>, 
and the timing of my discovery was great. xv6 had done what I had done,
and also implemented most of what I was planning to work on fotix
(for example, elf file loading), and it was a solid base for further 
development. It also had a userland, which fotix at the time didn‚Äôt have.</p>

<p>After I forked xv6, I spent some time familiriazing myself with the code.
I also cleaned up the source code quite a bit, structuring the code in a 
BSD like folder structure, instead of having all of the code in the same 
folder and made various small scale changes. </p>

<p>After that for quite some time, I had left ensidia alone and didn‚Äôt touch
it much. However, I always felt like I wanted to develop it a bit more
and get to play with its code in interesting ways. I was trying to think of
a great way to get started with kernel hacking on it, in a simple way, to 
get more acquainted with the kernel, and found an interesting pdf with 
interesting project ideas for it. One of them was to add a system call.
I figured out that would be an interesting and quick hack, so hey, why not?</p>

<h1 id="getting-started-with-kernel-hacking-on-xv6-adding-the-system-call">Getting started with kernel hacking on xv6: Adding the system call.</h1>

<p>The system call I decided to introduce was the suggested one. It was
fairly simple sounding too. You have to <strong>introduce a new system call
that returns the number of total system calls that have taken place
so far</strong>. So let‚Äôs see how I went about implementing it:</p>

<h2 id="an-introduction-to-system-calls-in-xv6">An introduction to system calls in xv6</h2>

<p>First of all, we should provide some context about what system calls are,
how they are used, and how they are implemented in xv6.</p>

<p>A system call is a function that a userspace application will use, so as
to ask for a specific service to be provided by the operating system. For
instance with an <code>sbrk(n)</code> system call, a process can ask the kernel to
grow its heap space by n bytes. Another example is the well known <code>fork()</code>
system call in the UNIX world, that‚Äôs used to create a new process by 
cloning the caller process.</p>

<p>The way applications signal the kernel that they need that service is
by issueing a software <em>interrupt</em>. An <em>interrupt</em> is a signal generated
that notifies the processor that it needs to stop what its currently doing,
and handle the interrupt. This mechanism is also used to notify the processor
that information it was seeking from the disks is in some buffer, ready to
be extracted and processed, or, that a key was pressed in the keyboard. This
is called a hardware interrupt.</p>

<p>Before the processor stops to handle the interrupt generated, it needs to 
save the current state, so that it can resume the execution in this context
after the interrupt has been handled. </p>

<p>The code that calls a system call in xv6 looks like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header' style='margin-bottom:-5px;'><span>initcode.S </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
# exec(init, argv)
 .globl start
 start:
   pushl $argv
   pushl $init
   pushl $0  // where caller pc would be
   movl $SYS_exec, %eax
   int $T_SYSCALL
</pre></div>
</div>
 </figure></notextile></div></p>

<p>In essence, it pushes the argument of the call to the stack, and puts
the system call number (in the above code, that‚Äôs <code>$SYS_exec</code>) into <code>%eax</code>.
The number is used to match the entry in an array that holds pointers to
all the system calls. After that, it generates a software interrupt, with
a code (in this case <code>$T_SYSCALL</code>) that‚Äôs used to index the interrupt
descriptor tables and find the appropriate interrupt handler. </p>

<p>The code that is specific to find the appropriate interrupt handler is
called <code>trap()</code> and is available in the file <code>trap.c</code>. If <code>trap()</code> check‚Äôs
out the trapnumber in the generated trapframe (a structure that represents
the processor‚Äôs state at the time that the trap happened) to be equal to
<code>T_SYSCALL</code>, it calls <code>syscall()</code> (the software interrupt handler)
 that‚Äôs available in <code>syscall.c</code></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header' style='margin-bottom:-5px;'><span>trap.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// This is the part of trap that</span>
<span class="comment">// calls syscall()</span>
<span class="directive">void</span>
trap(<span class="keyword">struct</span> trapframe *tf)
{
  <span class="keyword">if</span>(tf-&amp;gt;trapno == T_SYSCALL){
    <span class="keyword">if</span>(proc-&amp;gt;killed)
      exit();
    proc-&amp;gt;tf = tf;
    syscall();
    <span class="keyword">if</span>(proc-&amp;gt;killed)
      exit();
    <span class="keyword">return</span>;
  }
</pre></div>
</div>
 </figure></notextile></div></p>

<p><code>syscall()</code> is finally the function that checks out <code>%eax</code> to get the 
number of the system call (to index the array with the system 
call pointers), and execute the code corresponding to that system call.</p>

<p>The implementation of system calls in xv6 is under two files. The first one
is <code>sysproc.c</code>, and is the one containing the implementation of system calls
correspondent to processes, and <code>sysfile.c</code> that contains the implementation
of system calls regarding the file system.</p>

<h2 id="the-specific-implementation-of-the-numcalls-system-call">The specific implementation of the <code>numcalls()</code> system call</h2>

<p>To implement the system call itself is simple. I did so with a global variable
in <code>syscall.c</code> called <code>syscallnum</code>, that‚Äôs incremented everytime 
<code>syscall()</code>, calls a system call function, that is, the system call
is valid.</p>

<p>Next we just need a function, the system call implementation that returns
that number to the userspace program that asks for it. Below is the 
function itself, and <code>syscall()</code> after our change.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header' style='margin-bottom:-5px;'><span>sysproc.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// return the number of system calls that have taken place in</span>
<span class="comment">// the system</span>
<span class="predefined-type">int</span>
sys_numcalls(<span class="directive">void</span>)
{
    <span class="keyword">return</span> syscallnum;
}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header' style='margin-bottom:-5px;'><span>syscall.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// The syscall() implementation after</span>
<span class="comment">// our change</span>
<span class="directive">void</span>
syscall(<span class="directive">void</span>)
{
  <span class="predefined-type">int</span> num;&lt;/p&gt;

&lt;p&gt;num = proc-&amp;gt;tf-&amp;gt;eax;
  <span class="keyword">if</span>(num &amp;gt; <span class="integer">0</span> &amp;amp;&amp;amp; num &amp;lt; NELEM(syscalls) &amp;amp;&amp;amp; syscalls[num]) {
    syscallnum++; <span class="comment">// increment the syscall counter</span>
    proc-&amp;gt;tf-&amp;gt;eax = syscalls&lt;a href=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>&gt;num&lt;/a&gt;;
  } <span class="keyword">else</span> {
    cprintf(<span class="error">‚Äú</span>%d %s: unknown sys call %d<span class="error">\</span>n<span class="error">‚Äù</span>,
            proc-&amp;gt;pid, proc-&amp;gt;name, num);
    proc-&amp;gt;tf-&amp;gt;eax = -<span class="integer">1</span>;
  }
}
</pre></div>
</div>
 </figure></notextile></div></p>

<p>After that was done, the next few things that were needed to be done
were fairly straight forward. We had to add an index number for the new
system call in <code>syscall.h</code>, expose it to user proccesses via <code>user.h</code>,
and add a new macro to <code>usys.S</code> that defines an asm routine that calls
that specific system call, and change the makefile to facilitate our change
. After doing so we had to write a userspace testing program to test our changes.</p>

<p>The result after doing all this is below :)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
cpu1: starting
cpu0: starting
init: starting sh
$ ls
.              1 1 512
..             1 1 512
README         2 2 2209
cat            2 3 9725
echo           2 4 9254
forktest       2 5 5986
grep           2 6 10873
init           2 7 9579
kill           2 8 9246
ln             2 9 9240
ls             2 10 10832
mkdir          2 11 9315
rm             2 12 9308
sh             2 13 16600
stressfs       2 14 9790
usertests      2 15 37633
wc             2 16 10207
zombie         2 17 9028
syscallnum     2 18 9144
console        3 19 0
$ syscallnum
The total number of syscalls so far is 643
$ syscallnum
The total number of syscalls so far is 705
$ syscallnum
The total number of syscalls so far is 767
$ syscallnum
The total number of syscalls so far is 829
</pre></div>
</div>
 </figure></notextile></div></p>

<h1 id="epilogue">Epilogue</h1>

<p>I usually end my blog posts with an epilogue. Although this is a post
that doesn‚Äôt necesarilly need one, <strong>I wanted to write one just to say to you
that you should try kernel hacking</strong>, <em>that is programming jargon for
programming an operating system kernel</em>, because it‚Äôs an experience that
undoubtedly will teach you a great deal of things about how your computer
actually works.</p>

<p>Last but not least, take a look at the ongoing work on <a href="https://github.com/NlightNFotis/Ensidia">Ensidia, my fork
of xv6</a>. To see this particular
work, take a look at the <code>syscall</code> branch.</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://zoo.cs.yale.edu/classes/cs422/2010/reference">CS422/522: Operating systems, Yale</a></li>
  <li><a href="http://zoo.cs.yale.edu/classes/cs422/2010/xv6-book/fscall.pdf">Chapter 8, File System calls, xv6 reference, Yale</a></li>
  <li><a href="http://zoo.cs.yale.edu/classes/cs422/2010/xv6-book/trap.pdf">Chapter 3, System calls, exceptions and interrupts, Yale</a></li>
  <li><a href="http://pdos.csail.mit.edu/6.828/2012/xv6/book-rev7.pdf">xv6 Documentation, MIT csail</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How the compiler, the Library and the Kernel work - Part 2 ]]></title>
    <link href="http://NlightNFotis.github.io/blog/2014/04/25/how-the-compiler/"/>
    <updated>2014-04-25T18:27:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2014/04/25/how-the-compiler</id>
    <content type="html"><![CDATA[<p>In the previous part of this little series, we talked about the compiler, and what it does 
with the header files, in our attempt to demistify their usage. In this part, I want to show you
what‚Äôs the compiler‚Äôs output, and how we create our file.</p>

<h1 id="the-compilers-composition">The compiler‚Äôs composition</h1>

<p>Generally speaking, a <em>compiler</em> belongs to a family of software called <strong>translators</strong>. 
A translator‚Äôs job is to read some source code in a source language, and generate (translate it to) 
some source code in a target language.</p>

<p>Now, you might think that most compilers you know don‚Äôt do that. You input a (source code) file, 
and you get a binary file, ready to run when you want it to. Yes that‚Äôs what it does, but it‚Äôs not
the compiler that does all this. If you remember from the last installment of this series,
when you call the compiler like <code>gcc some_file.c</code> or <code>clang some_file.c</code>, in essence you are
calling the compilation driver, with the file as a parameter. The compilation driver then calls
1) the preprocessor, 2) the (actual) compiler, 3) the assembler and last but not least the linker.
At least when it comes to gcc, these pieces of software are called <code>cpp</code>, <code>cc1</code>, 
<code>gas</code> (executable name is <code>as</code>)  and <code>collect2</code> (executable name is <code>ld</code>) respectively.</p>

<p>From that little software collection up top, that we call the compiler, we can easily take notice
of at least 3 (yeah, that‚Äôs right) translators, that act as we mentioned earlier, 
that is take some input in a source language, and produce some output to a target language.</p>

<p>The first is the preprocessor. The preprocessor accepts source code in C as a source language,
and produces source code again in C (as a target language), but with the output having various
elements of the source code resolved, such as header file inclusion, macro expansion, etc.</p>

<p>The second is the compiler. The compiler accepts (in our case) C source code, as a source language,
and translates it to some architecture‚Äôs assembly language. In my case, when I talk about the 
compiler, I‚Äôm gonna assume that it produces x86 assembly.</p>

<p>The last one, is the assembler, which accepts as input some machine‚Äôs architecture assembly
language, and produces what‚Äôs called binary, or object representation of it, that is it translates
the assembly mnemonics directly to the bytes they correspond to, in the target architecture.</p>

<p>At this point, one could also argue that the linker is also a translator, accepting binary, and 
translating it to an executable file, that is, resolving references, and fitting the binary code
on the segments of the file that is to be produced. For example, on a typical GNU/Linux system,
this phase produces the executable ELF file.</p>

<h1 id="the-actual-compilers-output-x86-assembly">The (actual) compiler‚Äôs output: x86 assembly.</h1>

<p>Before we go any further, I would like to show you what the compiler really creates:</p>

<p>For the typical hello world program we demonstrated in our first installment, the compiler
will output the following assembly code:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header' style='margin-bottom:-5px;'><span>hello.S </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
        .file        ‚Äúhello.c‚Äù
        .section        .rodata
.LC0:
        .string        ‚ÄúHello world!‚Äù
        .text
        .globl        main
        .type        main, @function
main:
        pushq        %rbp
        movq        %rsp, %rbp
        subq        $16, %rsp
        movl        %edi, -4(%rbp)
        movq        %rsi, -16(%rbp)
        movl        $.LC0, %edi
        call        puts
        movl        $0, %eax
        leave
        ret
        .size        main, .-main
        .ident        ‚ÄúGCC: (GNU) 4.8.2 20131212 (Red Hat 4.8.2-7)‚Äù
        .section        .note.GNU-stack,‚Äù‚Äù,@progbits
</pre></div>
</div>
 </figure></notextile></div></p>

<p>To produce the above file, we had to use the following gcc invocation command:
<code>gcc -S -fno-asynchronous-unwind-tables -o hello.S hello.c</code>. 
We used <code>-fno-asynchronous-unwind-tables</code> to remove <code>.cfi</code> directives, which tell <code>gas</code> 
(the gnu assembler) to emit Dwarf Call Frame Information tags, which are used to reconstruct
a stack backtrace when a frame pointer is missing.</p>

<p>For more usefull compilation flags, to control the intermediary compilation flow, try these:</p>

<ul>
  <li><code>-E</code>: stop after preprocessing, and produce a *.i file</li>
  <li><code>-S</code>: we used this, stop after the compiler, and produce a *.s file</li>
  <li><code>-c</code>: stop after the assembler, and produce a *.o file.</li>
</ul>

<p>The default behaviour is to use none, and stop after the linker has run. If you want to run a 
full compilation and keep all the intermediate files, use the <code>-save-temps</code> flag.</p>

<h1 id="from-source-to-binary-the-assembler">From source to binary: the assembler.</h1>

<p>The next part of the compilation process, is the assembler. We have already discussed what
the assembler does, so here we are going to see it in practice. If you have followed so far,
you should have two files, a <code>hello.c</code>, which is the hello world‚Äôs C source code file,
and a <code>hello.S</code> which is what we created earlier, the compiler‚Äôs (x86) assembly output.</p>

<p>The assembler operates on that last file as you can imagine, and to see it running, and emit
binary, we need to invoke it like this: <code>as -o hello.bin hello.S</code>, and produces this:</p>

<pre><code>ELF\00\00\00\00\00\00\00\00\00\00&gt;\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\F0\00\00\00\00\00\00\00\00\00\00\00@\00\00\00\00\00@\00\00\00UH\89\E5H\83\EC\89}\FCH\89u\F0\BF\00\00\00\00\E8\00\00\00\00\B8\00\00\00\00\C9\C3Hello world!\00\00GCC: (GNU) 4.8.2 20131212 (Red Hat 4.8.2-7)\00\00.symtab\00.strtab\00.shstrtab\00.rela.text\00.data\00.bss\00.rodata\00.comment\00.note.GNU-stack\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00@\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\B8\00\00\00\00\00\000\00\00\00\00\00\00\00	\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00&amp;\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00`\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00,\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00`\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\001\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00`\00\00\00\00\00\00\00
\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\009\00\00\00\00\00\000\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00m\00\00\00\00\00\00\00-\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00B\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\9A\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\9A\00\00\00\00\00\00\00R\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\B0\00\00\00\00\00\00\F0\00\00\00\00\00\00\00
\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00	\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\A0\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\F1\FF\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00	\00\00\00\00\00\00\00\00\00\00\00\00\00 \00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00hello.c\00main\00puts\00\00\00\00\00\00\00\00\00\00\00\00\00
\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00	\00\00\00\FC\FF\FF\FF\FF\FF\FF\FF
</code></pre>

<h1 id="last-but-not-least-the-linker">Last but not least: the linker</h1>

<p>We saw what the assembler emits, which is to say, binary code. However, that binary code
still needs further processing. To explain that, we need to go back a little.</p>

<p>In our first installment of the series, we said that when you call a function like <code>printf()</code>,
the compiler only needs its prototype to do type checking and ensure that you use it legally.
For that you include the header file <code>stdio.h</code>. But since that contains the function prototype only,
where is the source code for that function? Surely, it must be somewhere, since it executes 
successfully to begin with, but we haven‚Äôt met the source code for printf so far, so where is it?</p>

<p>The function‚Äôs source code is located in the <code>.so</code> (shared object) of the standard C library,
which in my system (Fedora 19, x64) is <code>libc-2.17.so</code>. I don‚Äôt want to expand on that further,
as I plan to do so on the next series installment, however, what we have said so far is enough
for you to understand the linker‚Äôs usage:</p>

<p>The linker resolves the undefined (thus far) reference to printf, by finding the reference to
the printf symbol and (in layman‚Äôs talk) 
making a pointer to point to it so that execution can jump to printf‚Äôs code
when we have to do that during our program‚Äôs execution.</p>

<p>To invoke the linker on our file, <a href="https://sourceware.org/binutils/docs-2.20/ld/Options.html#Options">at least according to it‚Äôs documentation</a>, 
we should do the following: <code>ld -o hello.out /lib/crt0.o hello.bin -lc</code>. Then we should
be able to run the file like this: <code>./hello.out</code>.</p>

<h1 id="epilogue">Epilogue</h1>

<p>That‚Äôs this end of this part 2 of my series that explains how your code turns into binary, and how
your computer (at least when it comes to the software side) runs it. In part 3, I am going to discuss
in greater length, the C library, and the kernel.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://stackoverflow.com/questions/3564752/what-is-cfi-and-lfe-in-assembly-code-produced-by-gcc-from-c-program">StackOverflow: What is .cfi and .LFE in assembly code produced by GCC from c++ program?</a></li>
  <li><a href="http://blog.lxgcc.net/?p=181">GCC front-end (1): driver vs. compiler</a></li>
  <li><a href="http://wiki.osdev.org/GAS">GAS</a></li>
  <li><a href="https://sourceware.org/binutils/docs-2.20/ld/"> ld: Binutils documentation</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How the compiler, the Library and the kernel work - Part 1]]></title>
    <link href="http://NlightNFotis.github.io/blog/2013/12/12/how-the-compiler/"/>
    <updated>2013-12-12T16:13:00+02:00</updated>
    <id>http://NlightNFotis.github.io/blog/2013/12/12/how-the-compiler</id>
    <content type="html"><![CDATA[<p>Before we get any further, it might be good if we provided some context.</p>

<h1 id="hello-world-again">Hello world. Again.</h1>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header' style='margin-bottom:-5px;'><span>helloworld.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="preprocessor">#include</span> <span class="include">&lt;stdio.h /&gt;</span>&lt;/p&gt;

&lt;p&gt;<span class="predefined-type">int</span>
main (<span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> **argv)
{
    printf (<span class="error">‚Äú</span>Hello world!<span class="error">\</span>n<span class="error">‚Äù</span>);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="keyword">return</span> <span class="integer">0</span>; } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p>Every user space (read: application) programmer, has written a hello world program. 
Only god knows how many times this program has been written. Yet, 
most programmers‚Äô knowledge of the program is limited to something along the lines of:</p>

<blockquote>
  <ul>
    <li>It sends the string passed as a parameter to the system to print.  </li>
    <li>It takes the printf function from stdio.h and prints the string</li>
  </ul>
</blockquote>

<p>and various other things, which are anywhere between plain wrong, or partially correct. </p>

<p>** So why not demistify the process? **</p>

<h1 id="enter-the-c-preprocessor">Enter the C preprocessor.</h1>

<p>You may have heard of the C Preprocessor. It‚Äôs the first stage of a c or c++ file compilation,
and it‚Äôs actually responsible for things such as:</p>

<ul>
  <li><strong>inclusion of header files</strong> (it does so by replacing
<code>#include &lt;header.h&gt;</code> with the content of this file, and the file it includes recursively),</li>
  <li><strong>macro expansion</strong>, such as the famous comparison of two numbers (a greater than b). In essence, if you define
 the following macro <code>#define gt(a, b) ((a &gt; b) ? 1 : 0)</code>, then in a statement such as this:</li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre> <span class="keyword">if</span> (gt (<span class="integer">5</span>, <span class="integer">3</span>)) printf (<span class="string"><span class="delimiter">&quot;</span><span class="content">The first parameter is greater than the second.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
</pre></div>
</div>
</div>

<p><code>gt (5, 3)</code> gets expanded to the macro definition, so after the preprocessor has run you end up with something like this:</p>

<div><div class="CodeRay">
  <div class="code"><pre> <span class="keyword">if</span> (((<span class="integer">5</span> &gt; <span class="integer">3</span>) ? <span class="integer">1</span> : <span class="integer">0</span>)) printf (<span class="string"><span class="delimiter">&quot;</span><span class="content">The first parameter is greater than the second.</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>);
</pre></div>
</div>
</div>

<ul>
  <li><strong>conditional compilation</strong> (things such as: </li>
</ul>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="preprocessor">#ifdef</span> WIN32 
    printf (<span class="error">‚Äú</span>We are on windows<span class="error">\</span>n<span class="error">‚Äù</span>); 
<span class="preprocessor">#endif</span>
</pre></div>
</div>
 </figure></notextile></div></p>

<p>amongst others. You can see it for yourself. Write the hello world program, and pass it to cpp: <code>cpp hello_world.c</code></p>

<p>So now that we know what it does it‚Äôs time to demistify a common myth regarding it: <em>Some people believe
that the header files include the function to be called.</em>. <strong>That‚Äôs wrong.</strong> What it does include is 
<strong>function prototypes</strong> (and some type definitions, etc) <strong>only</strong>. It doesn‚Äôt include the body of the function
to be called.</p>

<p>Some people find that fact quite surprising, though, it isn‚Äôt, if you get to understand what the compiler
does with it.</p>

<h1 id="say-hello-to-the-compiler">Say hello to the compiler.</h1>

<p>Here we are gonna unmask another pile of misconceptions. First of all, some people think that when they call 
<code>gcc</code> on the command line they are actually calling the compiler. <strong>They are not.</strong> <em>In fact they are calling
the software commonly called <strong>the compilation driver</strong>, whose job is to run all the software needed to fully
turn source to binary, including preprocessors, the actual compiler, an assembler and finally the linker</em></p>

<p>Having said that, the actual compiler that‚Äôs getting called when you call <code>gcc</code> is called <code>cc1</code>. You may have seen it some times when the driver reports errors. Wanna take a look at it, to make sure I‚Äôm not lying to you? 
(Hint: I‚Äôm not!) Fair enough. Why don‚Äôt you type this in the command line: <code>gcc -print-prog-name=cc1</code>. It should tell you where the actual compiler is located in your system.</p>

<p>So now that we have this (misconception) out of our minds, we can continue with our analysis. Last time we talked
about it, we said that the header files include <strong>prototypes</strong> and not the whole function.</p>

<p>You may know that in C, you usually declare a function, before you use it. The primary reason for doing this
is to provide the compiler with the ability to perform <strong>type checking</strong>, that is to check that the arguments
passed are correct, both in number, and in type, and to verify that the returned value (assuming there is one)
is being used correctly. Below is a program that demonstrates the function prototype:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption class='code-header' style='margin-bottom:-5px;'><span>prototype.c </span></figcaption>
 <div class="CodeRay">
  <div class="code"><pre>
<span class="preprocessor">#include</span> <span class="include">&lt;stdio.h /&gt;</span>&lt;/p&gt;

&lt;p&gt;<span class="predefined-type">int</span> add_nums (<span class="predefined-type">int</span> first, <span class="predefined-type">int</span> second);&lt;/p&gt;

&lt;p&gt;<span class="predefined-type">int</span>
main (<span class="directive">void</span>)
{
    printf (<span class="error">‚Äú</span><span class="integer">5</span> + <span class="integer">5</span> results in %d<span class="error">\</span>n<span class="error">‚Äù</span>, add_nums (<span class="integer">5</span>, <span class="integer">5</span>));&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="keyword">return</span> <span class="integer">0</span>; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;<span class="predefined-type">int</span>
add_nums (<span class="predefined-type">int</span> first, <span class="predefined-type">int</span> second)
{
    <span class="keyword">return</span> first + second;
}
</pre></div>
</div>
 </figure></notextile></div></p>

<p>In this particular example, the prototype gives the compiler a wide variety of information. It tells it
that function <code>add_nums</code> takes two int arguments and returns an integer to the calling function. Now the
compiler can verify that I am passing correct arguments to it when I call it inside printf. If I don‚Äôt include
the function prototype, and do something slightly evil such as calling <code>add_nums</code> with <code>float</code> arguments then 
this might happen:</p>

<pre><code>5 + 4 results in 2054324224
</code></pre>

<p>Now that you know that the compiler (the real one) only needs the prototype and not the actual function code,
you may be wondering how the compiler actually compiles it if it doesn‚Äôt know it‚Äôs code.</p>

<p>Now is the time to bring down another missconception. The word <em>compiler</em> is just a fancy name for software
otherwise known as <em>translators</em>. A <em>translator‚Äôs</em> job is to get input and turn it from one language (source language) to a second language (target language), whatever that may be. Most of the times, when you compile software,
you compile it to run in your computer, which runs on a processor from the x86 architecture family of processors.
A processor is typically associated with an assembly language for that architecture (which is just human friendly
mnemonics for common processor tasks), so your <em>x86 computer runs x86 assembly</em> (ok that‚Äôs not 100% true, but for
simplicity‚Äôs sake at the moment, it should serve. We will see why it‚Äôs not true later.) So the compiler 
(in a typical translation) translates (compiles) your C source code to x86 assembly. 
You can see this by compiling your hello world example and passing the compiler the <code>-S</code> (which asks it to stop,
after x86 assembly is produced) parameter, likewise <code>gcc -S hello.c</code>.</p>

<h1 id="conclusion">Conclusion</h1>

<p>At this part, we saw how the compiler and the preprocessor work with our code, in an attempt to demistify the 
so called library calls. In the next part, we are going to study the assembler and the linker, and for the final
part the loader and the kernel.</p>
]]></content>
  </entry>
  
</feed>
