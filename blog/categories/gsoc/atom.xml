<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: gsoc | Fotis Koutoulakis]]></title>
  <link href="http://NlightNFotis.github.io/blog/categories/gsoc/atom.xml" rel="self"/>
  <link href="http://NlightNFotis.github.io/"/>
  <updated>2013-08-19T12:33:41+03:00</updated>
  <id>http://NlightNFotis.github.io/</id>
  <author>
    <name><![CDATA[Fotis Koutoulakis]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GSOC Week 9 (Partial) report]]></title>
    <link href="http://NlightNFotis.github.io/blog/2013/08/19/gsoc-week-9-partial-report/"/>
    <updated>2013-08-19T11:35:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2013/08/19/gsoc-week-9-partial-report</id>
    <content type="html"><![CDATA[<p>This week was revolving around the print debugging in the gccgo runtime in search
for clues regarding the creation of new threads under the goruntime, so as to see
if there is something wrong with the runtime itself, or the way the runtime
interacts with the libpthread.</p>

<h2>(partial presentation of) findings</h2>

<p>During print debugging the gccgo runtime, I didn&rsquo;t notice anything abnormal or
unusual so far. For example, the code that does trigger the assertion failure
seems to work at least once, since <code>pthread_create()</code> returns <code>0</code> at least once.</p>

<p>This is expected behavior, since we already have stated that there is at least
one <code>M</code> (kernel thread) created at the initialisation of the program&rsquo;s runtime.</p>

<p>If however, we try to use a <em>go statement</em> in our program, to make usage of a
goroutine, the runtime still fails at the usual assertion fail, however the
output of the program is this:</p>

<p><code>
root@debian:~/Software/Experiments/go# ./a.out
[DEBUG] pthread_create returned 0
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</code></p>

<p>The above output can give us some pieces of information:</p>

<ul>
<li><code>pthread_create()</code> is called at least once.</li>
<li>it executes successfuly and without errors &ndash; libpthread code suggests that 0 is returned upon successful execution and creation of a thread</li>
<li>However the assertion is still triggered, which we know it&rsquo;s getting triggered during thread creation.</li>
</ul>


<p>The second bullet point is also being supported by the fact that even if you exe
cute something as simple as hello world in go, a new M is created, so you get
something along the lines of this as an output:</p>

<p><code>
root@debian:~/Software/Experiments/go# ./a.out
[DEBUG] pthread_create returned 0
Hello World!
root@debian:~/Software/Experiments/go#
</code></p>

<p>There is however something that the above piece of code doesn&rsquo;t tell us,
but it would be useful to know: <em>How many times did we create a new thread?</em>
So we modify our gcc&rsquo;s source code to see how many times the runtimes
attempts to create a new kernel thread (M). This is what we get out of it:</p>

<p><code>
root@debian:~/Software/Experiments/go# ./a.out
[DEBUG] Preparing to create a new thread.
[DEBUG] pthread_create returned 0
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
[DEBUG] Preparing to create a new thread.
aborted.
</code></p>

<p>The code at this point in the runtime is this:</p>

<p>``` c proc.c
// Create a new m.  It will start off with a call to runtime_mstart.
M*
runtime_newm(void)
{</p>

<pre><code>M *mp;
pthread_attr_t attr;
pthread_t tid;
size_t stacksize;
sigset_t clear;
sigset_t old;
int ret;
</code></pre>

<h1>if 0</h1>

<pre><code>static const Type *mtype;  // The Go type M
if(mtype == nil) {
    Eface e;
    runtime_gc_m_ptr(&amp;e);
    mtype = ((const PtrType*)e.__type_descriptor)-&gt;__element_type;
}
</code></pre>

<h1>endif</h1>

<pre><code>// XXX: Added by fotis for print debugging.
printf("[DEBUG] Preparing to create a new thread.\n")

mp = runtime_mal(sizeof *mp);
mcommoninit(mp);
mp-&gt;g0 = runtime_malg(-1, nil, nil);

if(pthread_attr_init(&amp;attr) != 0)
    runtime_throw("pthread_attr_init");
if(pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED) != 0)
    runtime_throw("pthread_attr_setdetachstate");

// &lt;http://www.gnu.org/software/hurd/open_issues/libpthread_set_stack_size.html&gt;
</code></pre>

<h1>ifdef <strong>GNU</strong></h1>

<pre><code>stacksize = StackMin;
</code></pre>

<h1>else</h1>

<pre><code>stacksize = PTHREAD_STACK_MIN;

// With glibc before version 2.16 the static TLS size is taken
// out of the stack size, and we get an error or a crash if
// there is not enough stack space left.  Add it back in if we
// can, in case the program uses a lot of TLS space.  FIXME:
// This can be disabled in glibc 2.16 and later, if the bug is
// indeed fixed then.
stacksize += tlssize;
</code></pre>

<h1>endif</h1>

<pre><code>if(pthread_attr_setstacksize(&amp;attr, stacksize) != 0)
    runtime_throw("pthread_attr_setstacksize");

// Block signals during pthread_create so that the new thread
// starts with signals disabled.  It will enable them in minit.
sigfillset(&amp;clear);
</code></pre>

<h1>ifdef SIGTRAP</h1>

<pre><code>// Blocking SIGTRAP reportedly breaks gdb on Alpha GNU/Linux.
sigdelset(&amp;clear, SIGTRAP);
</code></pre>

<h1>endif</h1>

<pre><code>sigemptyset(&amp;old);
sigprocmask(SIG_BLOCK, &amp;clear, &amp;old);
ret = pthread_create(&amp;tid, &amp;attr, runtime_mstart, mp);

/* XXX: added for debug printing */
printf("[DEBUG] pthread_create() returned %d\n", ret);

sigprocmask(SIG_SETMASK, &amp;old, nil);

if (ret != 0)
    runtime_throw("pthread_create");

return mp;
</code></pre>

<p>}
```</p>

<p>We can deduce two things about our situation right now:</p>

<ul>
<li>There is <strong>at least one</strong> thread successfully created, and there is an attempt
to create another one.</li>
<li>The second time, there is a failure before pthread_create is called.</li>
</ul>


<h2>Continuation of work.</h2>

<p>I have been following this course of path the last week. I presented
some of my findings, and hope to soon be able to write an exhaustive
report on what exactly it is that causes the bug.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GSOC Week 8 (Partial) report]]></title>
    <link href="http://NlightNFotis.github.io/blog/2013/08/12/gsoc-week-8-partial-report/"/>
    <updated>2013-08-12T10:27:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2013/08/12/gsoc-week-8-partial-report</id>
    <content type="html"><![CDATA[<p>This week was spent studying the go language&rsquo;s runtime and studying the behaviour of various go programs when executed under the Hurd. I learnt a variety of new things, and got some
new clues about the problem.</p>

<h2>The new libgo clues</h2>

<p>I already know that <em>M&rsquo;s are the &ldquo;real&rdquo; kernel schedulable threads</em> and <em>G&rsquo;s are the go runtime managed ones (goroutines)</em>. Last time I had gone through the go runtime&rsquo;s code I had noticed that neither of them get created, so there must be an issue with thread creation. <strong>But since there is at least one of each created during the program&rsquo;s initialization, how come
most programs are able to run, and issues present themselves when we manually attempt to run a goroutine?</strong></p>

<p>I will admit that the situation looks strange. So I decided to look more into it. Before we go any further, I have to embed the issues I had when I run goroutine powered programs under the Hurd.</p>

<p><code>
root@debian:~/Software/Experiments/go# ./a.out
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</code></p>

<p><code>__pthread_create_internal</code> is a libpthread function that gets called when a new posix thread is instanciated. So we know that when we call a goroutine, apart from the goroutine,
there is at least one kernel thread created, otherwise, if a new goroutine was created, and not a new kernel thread (M) why wasn&rsquo;t it matched with an existing kernel thread
(remember there is at least one).</p>

<p>That made me look into the go runtime some more. I found a lot of things, that I can not enumerate here, but amongst the most interesting ones, was the following piece of code:</p>

<p>```go proc.c</p>

<p>// Create a new m.  It will start off with a call to runtime_mstart.
M*
runtime_newm(void)
{</p>

<pre><code>M *mp;
pthread_attr_t attr;
pthread_t tid;
size_t stacksize;
sigset_t clear;
sigset_t old;
int ret;
</code></pre>

<h1>if 0</h1>

<pre><code>static const Type *mtype;  // The Go type M
if(mtype == nil) {
    Eface e;
    runtime_gc_m_ptr(&amp;e);
    mtype = ((const PtrType*)e.__type_descriptor)-&gt;__element_type;
}
</code></pre>

<h1>endif</h1>

<pre><code>mp = runtime_mal(sizeof *mp);
mcommoninit(mp);
mp-&gt;g0 = runtime_malg(-1, nil, nil);

if(pthread_attr_init(&amp;attr) != 0)
    runtime_throw("pthread_attr_init");
if(pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED) != 0)
    runtime_throw("pthread_attr_setdetachstate");

stacksize = PTHREAD_STACK_MIN;

// With glibc before version 2.16 the static TLS size is taken
// out of the stack size, and we get an error or a crash if
// there is not enough stack space left.  Add it back in if we
// can, in case the program uses a lot of TLS space.  FIXME:
// This can be disabled in glibc 2.16 and later, if the bug is
// indeed fixed then.
stacksize += tlssize;

if(pthread_attr_setstacksize(&amp;attr, stacksize) != 0)
    runtime_throw("pthread_attr_setstacksize");

// Block signals during pthread_create so that the new thread
// starts with signals disabled.  It will enable them in minit.
sigfillset(&amp;clear);
</code></pre>

<h1>ifdef SIGTRAP</h1>

<pre><code>// Blocking SIGTRAP reportedly breaks gdb on Alpha GNU/Linux.
sigdelset(&amp;clear, SIGTRAP);
</code></pre>

<h1>endif</h1>

<pre><code>sigemptyset(&amp;old);
sigprocmask(SIG_BLOCK, &amp;clear, &amp;old);
ret = pthread_create(&amp;tid, &amp;attr, runtime_mstart, mp);
sigprocmask(SIG_SETMASK, &amp;old, nil);

if (ret != 0)
    runtime_throw("pthread_create");

return mp;
</code></pre>

<p>}
```</p>

<p>This is the code that creates a new kernel thread. Notice the line <code>ret = pthread_create(&amp;tid, &amp;attr, runtime_mstart, mp);</code>. It&rsquo;s obvious that it creates a new kernel thread,
so that explains why we get the specific error. But what is not explained is that since we do have at least one in program startup, why is this specific error only triggered when
we manually create a go routine?</p>

<h2>Go programs under the Hurd</h2>

<p>Apart from studying Go&rsquo;s runtime source code, I also run some experiments under the Hurd. I got some very weird results that I am investigating, but I would like to share nonetheless.
Consider the following piece of code:</p>

<p>```go hellogoroutines.go</p>

<p>package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func say(s string) {</p>

<pre><code>for i := 0; i &lt; 5; i++ {
    fmt.Println(s)
}
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>say("world")
say("hello")
</code></pre>

<p>}
```</p>

<p>A very basic example that can demonstrate goroutines. Now, if we change <strong>one</strong> of the say functions inside main to a goroutine, this happens:</p>

<p><code>
root@debian:~/Software/Experiments/go# ./a.out
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion `({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid;
__mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })' failed.
Aborted
</code></p>

<p><strong>BUT</strong> if we change <strong>BOTH</strong> of these functions to goroutines (<code>go say("world")</code>, <code>go say("hello")</code>), this happens:</p>

<p><code>
root@debian:~/Software/Experiments/go# ./a.out
root@debian:~/Software/Experiments/go#
</code></p>

<p>Wait a minute. It can&rsquo;t be! Did it execute correctly? Where is the output?</p>

<p><code>
root@debian:~/Software/Experiments/go# echo $?
0
root@debian:~/Software/Experiments/go#
</code></p>

<p>It reports that it has executed correctly. But there is no output.</p>

<h2>What I am doing next</h2>

<p>I will continue reading through the go runtime for some clues. On the more active size, I am writing a custom test case for goroutine testing under the Hurd, while also doing some analysis
on the programs that run there (currently studying the assembly generated for these programs) to see how they differ and why we get this particular behavior.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GSOC (Partial) Week 7 report]]></title>
    <link href="http://NlightNFotis.github.io/blog/2013/08/05/gsoc-partial-week-7-report/"/>
    <updated>2013-08-05T01:36:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2013/08/05/gsoc-partial-week-7-report</id>
    <content type="html"><![CDATA[<h1>An exciting week.</h1>

<p>This week was exciting. Spending it on learning about the go runtime was the reason for this. As insightfull as it was however,
it also confused me a little bit. Before this goes any further, I should state that this is a partial report on my research
and my findings. My aims for this week were the following: <strong>To investigate the behavior of go programs under the Hurd, to
study the go runtime, and possibly modify it to see if the goroutine issues are libpthread&rsquo;s issue or the go&rsquo;s runtime issue</strong>.</p>

<h1>Presenting my findings.</h1>

<p>Most of my time was spent studying the gcc go frontend, libgo and the go runtime. Fortunatelly, I can say (gladly) that it was
time well spent. What I got from it were some nice pieces of insight, but also some slight confusion and doubts.</p>

<p>The first interesting thing in my findings was this:</p>

<p>``` go runtime.h</p>

<p>struct  G
{</p>

<pre><code>Defer*  defer;
Panic*  panic;
void*   exception;  // current exception being thrown
bool    is_foreign; // whether current exception from other language
void    *gcstack;   // if status==Gsyscall, gcstack = stackbase to use during gc
uintptr gcstack_size;
void*   gcnext_segment;
void*   gcnext_sp;
void*   gcinitial_sp;
ucontext_t gcregs;
byte*   entry;      // initial function
G*  alllink;    // on allg
void*   param;      // passed parameter on wakeup
bool    fromgogo;   // reached from gogo
int16   status;
int64   goid;
uint32  selgen;     // valid sudog pointer
const char* waitreason; // if status==Gwaiting
G*  schedlink;
bool    readyonstop;
bool    ispanic;
bool    issystem;
int8    raceignore; // ignore race detection events
M*  m;      // for debuggers, but offset not hard-coded
M*  lockedm;
M*  idlem;
int32   sig;
int32   writenbuf;
byte*   writebuf;
// DeferChunk   *dchunk;
// DeferChunk   *dchunknext;
uintptr sigcode0;
uintptr sigcode1;
// uintptr  sigpc;
uintptr gopc;   // pc of go statement that created this goroutine

int32   ncgo;
CgoMal* cgomal;

Traceback* traceback;

ucontext_t  context;
void*       stack_context[10];
</code></pre>

<p>};
```</p>

<p>Yep. This is the code that resembles a (yeah, you guessed it, a <strong>goroutine</strong>). I was pretty surprised at first to see that a thread is resembled as a struct. But then again,
taking a closer look at it, it makes perfect sense. The next one though was a <em>lot trickier</em>:</p>

<p>```go runtime.h</p>

<p>struct  M
{</p>

<pre><code>G*  g0;     // goroutine with scheduling stack
G*  gsignal;    // signal-handling G
G*  curg;       // current running goroutine
int32   id;
int32   mallocing;
int32   throwing;
int32   gcing;
int32   locks;
int32   nomemprof;
int32   waitnextg;
int32   dying;
int32   profilehz;
int32   helpgc;
uint32  fastrand;
uint64  ncgocall;   // number of cgo calls in total
Note    havenextg;
G*  nextg;
M*  alllink;    // on allm
M*  schedlink;
MCache  *mcache;
G*  lockedg;
G*  idleg;
Location createstack[32];   // Stack that created this thread.
M*  nextwaitm;  // next M waiting for lock
uintptr waitsema;   // semaphore for parking on locks
uint32  waitsemacount;
uint32  waitsemalock;
GCStats gcstats;
bool    racecall;
void*   racepc;

uintptr settype_buf[1024];
uintptr settype_bufsize;

uintptr end[];
</code></pre>

<p>};
```</p>

<p>This was a source of endless confusion at the beginning. It does have some hints reassuring the fact that G&rsquo;s are indeed goroutines, but nothing that really helps to describe what an M is.
It&rsquo;s structure is identical to that of the G however, which means that it might have something to do with a thread. And indeed it is. Further study of the source code
made me speculate that <strong>M&rsquo;s must be the real operating system scheduled (kernel) threads, while G&rsquo;s (goroutines) must be the lightweight threads managed by the go runtime.</strong></p>

<p>I was more than happy to find comments that reassured that position of mine.</p>

<p><code>
// The go scheduler's job is to match ready-to-run goroutines (`g's)
// with waiting-for-work schedulers (`m's)
</code></p>

<p>Another cool finding was the go (runtime) scheduler &ndash; from which the above comment originates:</p>

<p>```go proc.c</p>

<p>struct Sched {</p>

<pre><code>Lock;

G *gfree;   // available g's (status == Gdead)
int64 goidgen;

G *ghead;   // g's waiting to run
G *gtail;
int32 gwait;    // number of g's waiting to run
int32 gcount;   // number of g's that are alive
int32 grunning; // number of g's running on cpu or in syscall

M *mhead;   // m's waiting for work
int32 mwait;    // number of m's waiting for work
int32 mcount;   // number of m's that have been created

volatile uint32 atomic; // atomic scheduling word (see below)

int32 profilehz;    // cpu profiling rate

bool init;  // running initialization
bool lockmain;  // init called runtime.LockOSThread

Note    stopped;    // one g can set waitstop and wait here for m's to stop
</code></pre>

<p>};
```</p>

<p>From that particular piece of code, without a doubt the most interesting line is: <code>G *gfree</code>. That is a pool of the go routines that are available to be used.
There are also helper schedulling functions, from which, the most interesting (for my purposes), was the <code>static void gfput(G*);</code> which realeases a go routine (puts it to the gfree list)</p>

<p>```go proc.c</p>

<p>// Put on gfree list.  Sched must be locked.
static void
gfput(G *gp)
{</p>

<pre><code>gp-&gt;schedlink = runtime_sched.gfree;
runtime_sched.gfree = gp;
</code></pre>

<p>}
```
There are loads of other extremely interesting functions there, but for the sake of space I will not expand here more. However I will expand on what it is that is confusing me:</p>

<h2>The source of confusion</h2>

<p>My tests in this point are to include testing if removing thread destruction from the go runtime would result in difference in behavior.
There are however (as far as go is concerned), two kinds of threads in the go runtime. <strong>Goroutines</strong> (G&rsquo;s) and the <strong>kernel schedulable threads</strong> (M&rsquo;s).</p>

<p>Neither of which, seem to really be destroyed. From my understanding so far, G&rsquo;s are never totally destroyed (I may be wrong here, I am still researching this bit). Whenever
they are about to &ldquo;destroyed&rdquo;, they are added to the scheduler&rsquo;s list of freeG&rsquo;s to allow for reuse, as evidenced by the <code>gfput</code> and <code>gfget</code> functions.
M&rsquo;s on the other hand (the kernel threads), also seem to not be destroyed. A comment in go&rsquo;s scheduler seems to support this (<code>// For now, m's never go away.</code>) and as a
matter of fact I could not find any code that destroyed M&rsquo;s (I am still researching this bit).</p>

<p><strong>Since none of the two actually get destroyed, and seeing as thread creation alone should not be buggy, how come we are facing the specific bugs we are facing?</strong>
I will try to provide with an interpretation: Either I am fairly wrong and M&rsquo;s (or G&rsquo;s or both) actually do get destroyed somewhere (possible and very much probable)
or I looking for clues regarding the issue in the wrong place (might be possible but I don&rsquo;t see it being very probable).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GSOC: Week 6 report]]></title>
    <link href="http://NlightNFotis.github.io/blog/2013/07/31/gsoc-week-6-report/"/>
    <updated>2013-07-31T12:36:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2013/07/31/gsoc-week-6-report</id>
    <content type="html"><![CDATA[<p>First of all, I would like to apologize for this report being late. But unfortunately this happened:
<img src="http://i1.kym-cdn.com/photos/images/original/000/000/376/Accidentally93mb20110724-22047-ix1t06.png" alt="I Accidentally 93 MB" /></p>

<p>Only that, in my case, it was not exactly 93 MB, rather it was about 1.5GB. Yeah, <em>I accidentally obliterated my <strong>GCC</strong> repository on the Hurd</em>, so I had to reclone and rebuild everything, something that took considerable amounts of time.
How this happened is a long story that involved me wanting to rebuild my gcc, and <code>cd</code>-ing 2 directories above the build folder, and ending up <code>rm -rf *</code> from my <code>gcc</code> folder (that included the source, and the build folder) rather than my <code>gcc_build</code> folder.
Thank god, that was only a minor setback, and the (small scale) crisis was soon averted.</p>

<h1>Further research</h1>

<p>This week was mostly spent reading source code, primarily looking for clues for the previous situation, and secondarily to get a better undestanding of the systems I am working on. This proved to be fertile, as I got a firmer grip of libpthread, and the GNU Mach system. However, while this week was mostly spent reading documentation, that doesn&rsquo;t mean that I didn&rsquo;t do anything practical. I also used my time to do some further research into what was it specifically that triggered the assertion failure. That required us to play a little bit with our newly built compiler on the Hurd and see what we can do with go on the Hurd.</p>

<h2>Testing gccgo under the Hurd</h2>

<p>If you recall correctly, the last time I reported I had found out that an assertion on <code>libpthread</code>`s code was failing, and that was the root cause that failed both the <code>gccgo</code> tests
and the <code>libgo</code> tests. That assertion was failing at two different places in the code, the first being <code>__pthread_create_internal</code> which is a <code>libpthread</code> function
located in <code>libpthread/pthread/pt-create.c</code> and is invoked when an application wants to create a new POSIX thread. That function of course is not getting called directly, rather
it is invoked by <code>pthread_create</code> which is the function that user space application use to create the new thread. (For reference reasons you can find the code <a href="https://github.com/NlightNFotis/libpthread/blob/master/pthread/pt-create.c#L67">here</a>)</p>

<p>The second place where that assertion was failing was at <code>__sem_timedwait_internal</code> at the file <a href="https://github.com/NlightNFotis/libpthread/blob/master/sysdeps/generic/sem-timedwait.c">libpthread/sysdeps/generic/sem-timedwait.c</a>, where it gets inlined in the place of <code>self = _pthread_self ();</code>. (For more information, checkout last week&rsquo;s report).</p>

<p>So I was curious to test out the execution of some sample programs under the compiler we built on the Hurd. <strong>Beginning with some very simple hello world like programs, we could see that
they were compiling successfully, and also ran successfully without any issues at all.</strong> Seeing as the assertion failure is generated when we attempt to create a new thread, I figured I might want to start playing with go routines under the Hurd.</p>

<p>So we started playing with a simple hello world like goroutine example (the one available under the <a href="http://tour.golang.org/#62">tour of go on the golang.org website.</a>)</p>

<p>```go</p>

<p>package main</p>

<p>import (</p>

<pre><code>"fmt"
"time"
</code></pre>

<p>)</p>

<p>func say(s string) {</p>

<pre><code>for i := 0; i &lt; 5; i++ {
    time.Sleep(100 * time.Millisecond)
    fmt.Println(s)
}
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>go say("world")
say("hello")
</code></pre>

<p>}
```</p>

<p>This gets compiled without any issues at all, but when we try to run it&hellip;</p>

<p><code>``
a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion</code>({ mach_port_t ktid = <strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; </strong>mach_port_deallocate ((<em>_mach_task_self</em> + 0), ktid); ok; })&lsquo; failed.
Aborted</p>

<p>goroutine 1 [sleep]:
time.Sleep</p>

<pre><code>../../../gcc_source/libgo/runtime/time.goc:26
</code></pre>

<p>goroutine 3 [sleep]:
time.Sleep</p>

<pre><code>../../../gcc_source/libgo/runtime/time.goc:26
</code></pre>

<p>```</p>

<p>Bam! It exploded right infront of our face. Let&rsquo;s see if this might become friendlier if we alter it a little bit. To do this we removed the <code>go</code> from <code>say</code> to avoid running it as a goroutine, and we also removed <code>time.Sleep</code> (along with the <code>time</code> import), <a href="https://github.com/NlightNFotis/gcc/blob/master/libgo/go/time/sleep.go#L8">whose job is to pause a go routine</a>.</p>

<p>When you do this, the code seems to be a hello world like for loop sample, that prints:</p>

<p><code>
root@debian:~/Software/Experiments/go# ./a.out
world
world
world
world
world
hello
hello
hello
hello
hello
</code></p>

<p>Hmm. Let&rsquo;s play with it some more. Changing our code a little bit to make <code>say("world")</code> run as a goroutine gives us the following code:</p>

<p>```go
package main</p>

<p>import &ldquo;fmt&rdquo;</p>

<p>func say(s string) {</p>

<pre><code>for i := 0; i &lt; 5; i++ {
    fmt.Println(s)
}
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>go say("world")
say("hello")
</code></pre>

<p>}
```</p>

<p>Which, when executed results in this:</p>

<p><code>``
root@debian:~/Software/Experiments/go# ./a.out
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion</code>({ mach_port_t ktid = <strong>mach_thread_self (); int ok = thread->kernel_thread == ktid;
</strong>mach_port_deallocate ((__mach_task_self + 0), ktid); ok; })&lsquo; failed.
Aborted</p>

<p>```</p>

<p>So we can see that the simplest go programs that run with goroutines do not run. Let&rsquo;s still try some programs that invoke goroutines to see if our assumptions are correct.
Below is the code of a very simple web server in go (<a href="http://tour.golang.org/#56">found in the golang website</a>).</p>

<p>```go webserver.go</p>

<p>package main</p>

<p>import (</p>

<pre><code>"fmt"
"net/http"
</code></pre>

<p>)</p>

<p>type Hello struct{}</p>

<p>func (h Hello) ServeHTTP(</p>

<pre><code>w http.ResponseWriter,
r *http.Request) {
fmt.Fprint(w, "Hello!")
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>var h Hello
http.ListenAndServe("localhost:4000", h)
</code></pre>

<p>}
```</p>

<p>The (non surprising) result is the following:</p>

<p><code>``
a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion</code>({ mach_port_t ktid = <strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; </strong>mach_port_deallocate ((<em>_mach_task_self</em> + 0), ktid); ok; })&lsquo; failed.
Aborted</p>

<p>goroutine 1 [syscall]:
no stack trace available
```</p>

<p>Hmm. This failure was last caused by <code>time.Sleep</code>. So let&rsquo;s take a closer look into the code of the <code>ListenAndServe</code> function. The code for this function in the go runtime is this:</p>

<p>```go gcc/libgo/go/net/http/server.go</p>

<p>// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.  If
// srv.Addr is blank, &ldquo;:http&rdquo; is used.
func (srv *Server) ListenAndServe() error {</p>

<pre><code>addr := srv.Addr
if addr == "" {
    addr = ":http"
}
l, e := net.Listen("tcp", addr)
if e != nil {
    return e
}
return srv.Serve(l)
</code></pre>

<p>}
```</p>

<p>This calls the function <a href="https://github.com/NlightNFotis/gcc/blob/master/libgo/go/net/http/server.go#L1255"><code>Serve</code></a>. The interesting part in this one is line 1271:</p>

<p>```go</p>

<p> time.Sleep(tempDelay)</p>

<p>```</p>

<p>It calls <code>time.Sleep</code> on accept failure. Which is known to pause go routines, and as a result be the ultimate cause for the result we are seeing.</p>

<h1>Final thoughts &ndash; Work for next week</h1>

<p>So pretty much everything that has anything to do with a goroutine is failing. Richard Braun on the #hurd suggested that since <strong>creation and destruction</strong> of threads is buggy in libpthread, maybe we should try a work around until a proper fix is in place.
Apart from that my mentor Thomas Schwinge suggested to make thread destruction in go&rsquo;s runtime a no-op to see if that makes any difference.
If it does that should mean that there is nothing wrong in the go runtime itself, rather, the offending code is in libpthread. This is also my very next course of action, which I shall report on very soon.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GSOC: Week 5 report]]></title>
    <link href="http://NlightNFotis.github.io/blog/2013/07/24/gsoc-week-5-report/"/>
    <updated>2013-07-24T12:36:00+03:00</updated>
    <id>http://NlightNFotis.github.io/blog/2013/07/24/gsoc-week-5-report</id>
    <content type="html"><![CDATA[<h1>A clue!</h1>

<p><strong>So last week we were left with the compiler test logs and the build results logs that we had to go through to checkout what was the root cause of all these failures in the gccgo test results, and more importantly in the libgo tests.</strong> So I went through the gccgo logs in search for a clue about why this may have happened. Here is the list of all the failures I compiled from the logs:</p>

<p>```</p>

<p>spawn [open &hellip;]^M
doubleselect.x: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion `({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_s      elf_ + 0), ktid); ok; })&lsquo; failed.
FAIL: go.test/test/chan/doubleselect.go execution,  -O2 -g</p>

<p>==========================================================</p>

<p>spawn [open &hellip;]^M
nonblock.x: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion `({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self_       + 0), ktid); ok; })&lsquo; failed.
FAIL: go.test/test/chan/nonblock.go execution,  -O2 -g</p>

<p>==========================================================</p>

<p>Executing on host: /root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo -B/root/gcc_new/gccbuild/gcc/testsuite/go/../../  -fno-diagnostics-show-caret -fdiagnostics-color=never  -I/root/gcc_new/gccbuild/i68      6-unknown-gnu0.3/./libgo  -fsplit-stack -c  -o split_stack376.o split_stack376.c    (timeout = 300)
spawn /root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo -B/root/gcc_new/gccbuild/gcc/testsuite/go/../../ -fno-diagnostics-show-caret -fdiagnostics-color=never -I/root/gcc_new/gccbuild/i686-unknown-gnu0.      3/./libgo -fsplit-stack -c -o split_stack376.o split_stack376.c<sup>M</sup>
cc1: error: &lsquo;-fsplit-stack&rsquo; currently only supported on GNU/Linux<sup>M</sup>
cc1: error: &lsquo;-fsplit-stack&rsquo; is not supported by this compiler configuration<sup>M</sup>
compiler exited with status 1
output is:
 cc1: error: &lsquo;-fsplit-stack&rsquo; currently only supported on GNU/Linux<sup>M</sup>
 cc1: error: &lsquo;-fsplit-stack&rsquo; is not supported by this compiler configuration<sup>M</sup></p>

<p>UNTESTED: go.test/test/chan/select2.go</p>

<p>==========================================================</p>

<p>Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open &hellip;]^M
select3.x: ./pthread/../sysdeps/generic/sem-timedwait.c:50: <strong>sem_timedwait_internal: Assertion `({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate       ((</strong>mach_task_self_ + 0), ktid); ok; })&lsquo; failed.
Aborted</p>

<p>FAIL: go.test/test/chan/select3.go execution,  -O2 -g</p>

<p>==========================================================</p>

<p>Executing on host: /root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo -B/root/gcc_new/gccbuild/gcc/testsuite/go/../../ /root/gcc_new/gcc/gcc/testsuite/go.test/test/chan/select5.go  -fno-diagnostics-show-      caret -fdiagnostics-color=never  -I/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo  -O  -w  -pedantic-errors  -L/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo -L/root/gcc_new/gccbuild/i686-unknown-      gnu0.3/./libgo/.libs  -lm   -o select5.exe    (timeout = 300)
spawn /root/gcc_new/gccbuild/gcc/testsuite/go/../../gccgo -B/root/gcc_new/gccbuild/gcc/testsuite/go/../../ /root/gcc_new/gcc/gcc/testsuite/go.test/test/chan/select5.go -fno-diagnostics-show-caret -fdiagno      stics-color=never -I/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo -O -w -pedantic-errors -L/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo -L/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.lib      s -lm -o select5.exe<sup>M</sup>
PASS: go.test/test/chan/select5.go -O (test for excess errors)
FAIL: go.test/test/chan/select5.go execution</p>

<p>==========================================================</p>

<p>Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open &hellip;]^M
bug147.x: ./pthread/../sysdeps/generic/sem-timedwait.c:50: <strong>sem_timedwait_internal: Assertion `({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate       ((</strong>mach_task_self_ + 0), ktid); ok; })&lsquo; failed.
Aborted</p>

<p>FAIL: go.test/test/fixedbugs/bug147.go execution,  -O2 -g</p>

<p>=========================================================</p>

<p>Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open &hellip;]^M
BUG: bug347: cannot find caller
Aborted</p>

<p>FAIL: go.test/test/fixedbugs/bug347.go execution,  -O0 -g</p>

<p>========================================================</p>

<p>Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open &hellip;]^M
BUG: bug348: cannot find caller
panic: runtime error: invalid memory address or nil pointer dereference
[signal 0xb code=0x2 addr=0x0]</p>

<p>goroutine 1 [running]:
FAIL: go.test/test/fixedbugs/bug348.go execution,  -O0 -g</p>

<p>========================================================</p>

<p>Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open &hellip;]^M
mallocfin.x: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion `({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self      _ + 0), ktid); ok; })&lsquo; failed.
FAIL: go.test/test/mallocfin.go execution,  -O2 -g</p>

<p>=======================================================</p>

<p>Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open &hellip;]^M
Aborted</p>

<p>FAIL: go.test/test/nil.go execution,  -O2 -g</p>

<p>======================================================</p>

<p>Setting LD_LIBRARY_PATH to .:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:.:/root/gcc_new/gccbuild/i686-unknown-gnu0.3/./libgo/.libs:/root/gcc_new/gccbuild/gcc:/root      /gcc_new/gccbuild/./gmp/.libs:/root/gcc_new/gccbuild/./prev-gmp/.libs:/root/gcc_new/gccbuild/./mpfr/.libs:/root/gcc_new/gccbuild/./prev-mpfr/.libs:/root/gcc_new/gccbuild/./mpc/.libs:/root/gcc_new/gccbuild      /./prev-mpc/.libs
spawn [open &hellip;]^M
Aborted</p>

<p>FAIL: go.test/test/recover3.go execution,  -O2 -g</p>

<p>```</p>

<p><em>See a pattern there?</em> Well certainly I do. In several occasions, the root cause for the fail is this:</p>

<p>``` c Assertion fail</p>

<p>Assertion `({ mach_port_t ktid = <strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; </strong>mach_port_deallocate       ((<em>_mach_task_self</em> + 0), ktid); ok; })&lsquo; failed.
```</p>

<p>Hmm&hellip; That&rsquo;s interesting. Let us go through the libgo results too.</p>

<p>```</p>

<p>Test Run By root on Fri Jul 12 17:56:44 UTC 2013
Native configuration is i686-unknown-gnu0.3</p>

<pre><code>    === libgo tests ===
</code></pre>

<p>a.out: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion <code>({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 10005 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: bufio
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (10005) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion</code>({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self<em> + 0), ktid); ok; })&lsquo; failed.
../../../gcc/libgo/testsuite/gotest: line 486: 10637 Aborted                 ./a.out -test.short -test.timeout=${timeout}s &ldquo;$@&rdquo;
FAIL: bytes
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (10637) &ndash; No such process
a.out: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion <code>({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 10757 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: errors
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (10757) - No such process
a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: __sem_timedwait_internal: Assertion</code>({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self</em> + 0), ktid); ok; })&rsquo; failed.
Aborted</p>

<p>goroutine 1 [syscall]:
no stack trace available
FAIL: expvar
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (10886) &ndash; No such process
a.out: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion <code>({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11058 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: flag
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11058) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion</code>({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self<em> + 0), ktid); ok; })&lsquo; failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11475 Aborted                 ./a.out -test.short -test.timeout=${timeout}s &ldquo;$@&rdquo;
FAIL: fmt
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11475) &ndash; No such process
a.out: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion <code>({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11584 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: html
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11584) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion</code>({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self</em> + 0), ktid); ok; })&rsquo; failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11747 Aborted                 ./a.out -test.short -test.timeout=${timeout}s &ldquo;$@&rdquo;
FAIL: image
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11747) &ndash; No such process
a.out: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion <code>({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 11999 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: io
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (11999) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion</code>({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self<em> + 0), ktid); ok; })&lsquo; failed.
../../../gcc/libgo/testsuite/gotest: line 486: 12116 Aborted                 ./a.out -test.short -test.timeout=${timeout}s &ldquo;$@&rdquo;
FAIL: log
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (12116) &ndash; No such process
a.out: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion <code>({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
../../../gcc/libgo/testsuite/gotest: line 486: 13107 Aborted                 ./a.out -test.short -test.timeout=${timeout}s "$@"
FAIL: math
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (13107) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion</code>({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self</em> + 0), ktid); ok; })&rsquo; failed.
../../../gcc/libgo/testsuite/gotest: line 486: 13271 Aborted                 ./a.out -test.short -test.timeout=${timeout}s &ldquo;$@&rdquo;
FAIL: mime
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (13271) &ndash; No such process
a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: <strong>sem_timedwait_internal: Assertion `({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self_ + 0), ktid); ok; })&lsquo; failed.
Aborted</p>

<p>goroutine 1 [chan receive]:
a.out: ./pthread/../sysdeps/generic/sem-timedwait.c:50: <strong>sem_timedwait_internal: Assertion <code>({ mach_port_t ktid = __mach_thread_self (); int ok = thread-&gt;kernel_thread == ktid; __mach_port_deallocate ((__mach_task_self_ + 0), ktid); ok; })' failed.
panic during panic
testing.RunTestsFAIL: net
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (14234) - No such process
a.out: ./pthread/pt-create.c:167: __pthread_create_internal: Assertion</code>({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self<em> + 0), ktid); ok; })&lsquo; failed.
../../../gcc/libgo/testsuite/gotest: line 486: 14699 Aborted                 ./a.out -test.short -test.timeout=${timeout}s &ldquo;$@&rdquo;
FAIL: os
timed out in gotest
../../../gcc/libgo/testsuite/gotest: line 484: kill: (14699) &ndash; No such process
a.out: ./pthread/pt-create.c:167: <strong>pthread_create_internal: Assertion `({ mach_port_t ktid = </strong>mach_thread_self (); int ok = thread->kernel_thread == ktid; <strong>mach_port_deallocate ((</strong>mach_task_self</em> + 0), ktid); ok; })&rsquo; failed.
../../../gcc/libgo/testsuite/gotest: line 486: 14860 Aborted                 ./a.out -test.short -test.timeout=${timeout}s &ldquo;$@&rdquo;
FAIL: path
timed out in gotest</p>

<p>&hellip;</p>

<p>runtest completed at Fri Jul 12 18:09:07 UTC 2013
```</p>

<p>That&rsquo;s certainly even more interesting. In case you haven&rsquo;t noticed, it&rsquo;s the same assertion that caused the failures in gccgo test suite. Let us find the offending code, shall we?</p>

<p>``` c libpthread/pthread/pt-create.c</p>

<p>/* Set the new thread&rsquo;s signal mask and set the pending signals to</p>

<pre><code> empty.  POSIX says: "The signal mask shall be inherited from the
 creating thread.  The set of signals pending for the new thread
 shall be empty."  If the currnet thread is not a pthread then we
 just inherit the process' sigmask.  */
</code></pre>

<p>  if (__pthread_num_threads == 1)</p>

<pre><code>err = sigprocmask (0, 0, &amp;sigset);
</code></pre>

<p>  else</p>

<pre><code>err = __pthread_sigstate (_pthread_self (), 0, 0, &amp;sigset, 0);
</code></pre>

<p>  assert_perror (err);</p>

<p>```</p>

<p>This seems to be the code that the logs point to. But no sign of the assertion. After discussing this issue with my peers in #hurd, I was told that the code I was looking for (the failing assertion), is getting inlined via <code>_pthread_self ()</code> and is actually located in <code>libpthread/sysdeps/mach/hurd/pt-sysdep.h</code>.</p>

<p>``` c libpthread/sysdeps/mach/hurd/pt-sysdep.h</p>

<p>extern <strong>thread struct </strong>pthread *___pthread_self;</p>

<h1>define _pthread_self()                                            \</h1>

<pre><code>({                                                         \
  struct __pthread *thread;                                \
                                                           \
  assert (__pthread_threads);                              \
  thread = ___pthread_self;                                \
                                                           \
  assert (thread);                                         \
  assert (({ mach_port_t ktid = __mach_thread_self ();     \
                 int ok = thread-&gt;kernel_thread == ktid;       \
                 __mach_port_deallocate (__mach_task_self (), ktid);\
                 ok; }));                                      \
      thread;                                                  \
     })
</code></pre>

<p>```</p>

<p>So this is what I was looking for. Further discussing it in the weekly IRC meeting, braunr provided me with some more clues:</p>

<blockquote><p>08:38:15 braunr> nlightnfotis: did i answer that ?<br/>
08:38:24 nlightnfotis> braunr: which one?<br/>
08:38:30 nlightnfotis> hello btw :)<br/>
08:38:33 braunr> the problems you&rsquo;re seeing are the pthread resources leaks i&rsquo;ve been trying to fix lately<br/>
08:38:58 braunr> they&rsquo;re not only leaks<br/>
08:39:08 braunr> creation and destruction are buggy <br/>
08:39:37 nlightnfotis> I have read so in <a href="http://www.gnu.org/software/hurd/libpthread.html.">http://www.gnu.org/software/hurd/libpthread.html.</a> I believe it&rsquo;s under Thread&rsquo;s Death right?<br/>
08:40:15 braunr> nlightnfotis: yes but it&rsquo;s buggy<br/>
08:40:22 braunr> and the description doesn&rsquo;t describe the bugs<br/>
08:41:02 nlightnfotis> so we will either have to find a temporary workaround, or better yet work on a fix, right?<br/>
08:41:12 braunr> nlightnfotis: i also told you the work around<br/>
08:41:16 braunr> nlightnfotis: create a thread pool</p></blockquote>

<h1>Work for next week</h1>

<p>This leaves us with next week&rsquo;s work, which is to hack in libpthread&rsquo;s code to attempt to create a thread pool, so that we avoid some of the issues that are present now with the current implementation of the Hurd libpthread code.</p>

<p>It was also suggested by Samuel Thibault (youpi) that I should run the libgo tests by hand and see if I get some more clues, like stack traces. It sounds like a good idea to me, so that&rsquo;s something that I will look into too.</p>
]]></content>
  </entry>
  
</feed>
